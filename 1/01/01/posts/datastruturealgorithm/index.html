<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>| xiaohei&#39;s blog | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content=赵小黑的各种记录><link rel=prev href=https://xiaohei.im/1/01/01/posts/linkedlist/><link rel=next href=https://xiaohei.im/1/01/01/posts/array/><link rel=canonical href=https://xiaohei.im/1/01/01/posts/datastruturealgorithm/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content><meta name=twitter:description content="复杂度分析 时间复杂度分析  只关注循环次数最多的一段代码 加法法则: 总复杂度等于量级最大的那段代码的复杂度 乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积  常见时间复杂度  O(1) 常量阶  没有循环,顺序执行
 O(n) 线性阶  循环 n 次
 O(logn) 对数阶
1 2 3 4 5  i=1; while (i &lt;= n) { i = i * 2; }    理解下来就是循环次数不是恒定的,就是 logn, 如果在上面代码中再套一层循环,就是 nlogn 了
 O(nlogn) 线性对数阶
 O(n^2^) 平方阶
  双重 for 循环
 O(m&#43;n)/O(m*n)  代码中有两个数据规模
空间复杂度分析 空间复杂度自己的理解就是申请了多大的空间来使用.申请一个固定大小的数组,那其实就是个常量阶,申请一个 n 大小的数组,复杂度就是 O(n),然后复杂一点的就是 O(n^2^)."><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xiaohei.im\/1\/01\/01\/posts\/datastruturealgorithm\/"},"image":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/cover.png","width":800,"height":600},"genre":"posts","wordcount":276,"url":"https:\/\/xiaohei.im\/1\/01\/01\/posts\/datastruturealgorithm\/","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX"></h1><div class=post-meta><div class=post-meta-main><a class=author href=https://xiaohei.im/ rel=author><i class="fas fa-user-circle fa-fw"></i>xiaoheiAh&nbsp;</a></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=0001-01-01>0001-01-01</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 276 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 2 分钟&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#复杂度分析>复杂度分析</a><ul><li><a href=#时间复杂度分析>时间复杂度分析</a><ul><li><a href=#常见时间复杂度>常见时间复杂度</a></li></ul></li><li><a href=#空间复杂度分析>空间复杂度分析</a></li><li><a href=#复杂度的几种情况>复杂度的几种情况</a><ul><li><a href=#最好时间复杂度>最好时间复杂度</a></li><li><a href=#最坏时间复杂度>最坏时间复杂度</a></li><li><a href=#平均时间复杂度>平均时间复杂度</a></li><li><a href=#均摊时间复杂度>均摊时间复杂度</a></li></ul></li></ul></li><li><a href=#数组-array>数组 Array</a><ul><li><ul><li><a href=#如何实现随机访问>如何实现随机访问?</a></li><li><a href=#数组为何适合查找>数组为何适合查找?</a></li><li><a href=#为什么数组要从0开始编号-而不是-1>为什么数组要从0开始编号,而不是 1?</a></li><li><a href=#二维数组如何寻址>二维数组如何寻址?</a></li></ul></li></ul></li><li><a href=#链表>链表</a><ul><li><ul><li><a href=#链表与数组的区别>链表与数组的区别?</a></li><li><a href=#实现一个-lru>实现一个 LRU?</a></li></ul></li></ul></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>目录</span><span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#复杂度分析>复杂度分析</a><ul><li><a href=#时间复杂度分析>时间复杂度分析</a><ul><li><a href=#常见时间复杂度>常见时间复杂度</a></li></ul></li><li><a href=#空间复杂度分析>空间复杂度分析</a></li><li><a href=#复杂度的几种情况>复杂度的几种情况</a><ul><li><a href=#最好时间复杂度>最好时间复杂度</a></li><li><a href=#最坏时间复杂度>最坏时间复杂度</a></li><li><a href=#平均时间复杂度>平均时间复杂度</a></li><li><a href=#均摊时间复杂度>均摊时间复杂度</a></li></ul></li></ul></li><li><a href=#数组-array>数组 Array</a><ul><li><ul><li><a href=#如何实现随机访问>如何实现随机访问?</a></li><li><a href=#数组为何适合查找>数组为何适合查找?</a></li><li><a href=#为什么数组要从0开始编号-而不是-1>为什么数组要从0开始编号,而不是 1?</a></li><li><a href=#二维数组如何寻址>二维数组如何寻址?</a></li></ul></li></ul></li><li><a href=#链表>链表</a><ul><li><ul><li><a href=#链表与数组的区别>链表与数组的区别?</a></li><li><a href=#实现一个-lru>实现一个 LRU?</a></li></ul></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=复杂度分析></a><h2>复杂度分析</h2><a class=post-dummy-target id=时间复杂度分析></a><h3>时间复杂度分析</h3><ol><li>只关注循环次数最多的一段代码</li><li>加法法则: 总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol><a class=post-dummy-target id=常见时间复杂度></a><h4>常见时间复杂度</h4><ol><li>O(1) 常量阶</li></ol><p>没有循环,顺序执行</p><ol><li>O(n) 线性阶</li></ol><p>循环 n 次</p><ol><li><p>O(logn) 对数阶</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c>   
<span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
<span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>)</span>  <span class=p>{</span>
  <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>}</span></code></pre></td></tr></table></div></div></li></ol><p>理解下来就是循环次数不是恒定的,就是 logn, 如果在上面代码中再套一层循环,就是 nlogn 了</p><ol><li><p>O(nlogn) 线性对数阶</p></li><li><p>O(n^2^) 平方阶</p></li></ol><p>双重 for 循环</p><ol><li>O(m+n)/O(m*n)</li></ol><p>代码中有两个数据规模</p><a class=post-dummy-target id=空间复杂度分析></a><h3>空间复杂度分析</h3><p>空间复杂度自己的理解就是申请了多大的空间来使用.申请一个固定大小的数组,那其实就是个常量阶,申请一个 n 大小的数组,复杂度就是 O(n),然后复杂一点的就是 O(n^2^).比较常见的就是这三种了.</p><a class=post-dummy-target id=复杂度的几种情况></a><h3>复杂度的几种情况</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=c1>// 全局变量，大小为10的数组array，长度len，下标i。
</span><span class=c1></span><span class=kt>int</span> <span class=n>array</span><span class=p>[]</span> <span class=o>=</span> <span class=n>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> 
<span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=c1>// 往数组中添加一个元素
</span><span class=c1></span><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>element</span><span class=p>)</span> <span class=p>{</span>
   <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 数组空间不够了
</span><span class=c1></span>     <span class=c1>// 重新申请一个2倍大小的数组空间
</span><span class=c1></span>     <span class=kt>int</span> <span class=n>new_array</span><span class=p>[]</span> <span class=o>=</span> <span class=n>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>len</span><span class=o>*</span><span class=mi>2</span><span class=p>];</span>
     <span class=c1>// 把原来array数组中的数据依次copy到new_array
</span><span class=c1></span>     <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>len</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
       <span class=n>new_array</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>array</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
     <span class=p>}</span>
     <span class=c1>// new_array复制给array，array现在大小就是2倍len了
</span><span class=c1></span>     <span class=n>array</span> <span class=o>=</span> <span class=n>new_array</span><span class=p>;</span>
     <span class=n>len</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>len</span><span class=p>;</span>
   <span class=p>}</span>
   <span class=c1>// 将element放到下标为i的位置，下标i加一
</span><span class=c1></span>   <span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>element</span><span class=p>;</span>
   <span class=o>++</span><span class=n>i</span><span class=p>;</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=最好时间复杂度></a><h4>最好时间复杂度</h4><p>最理想的情况下执行代码的复杂度,上述代码如果第一个就是要找的值,那就直接返回了.此时时间复杂度为 O(1)</p><a class=post-dummy-target id=最坏时间复杂度></a><h4>最坏时间复杂度</h4><p>最不理想的情况下执行代码的复杂度. 跑完整个代码都没找着或者最后一个才是,时间复杂度就是 O(n)</p><a class=post-dummy-target id=平均时间复杂度></a><h4>平均时间复杂度</h4><p>每种情况遍历次数之和/情况总数</p><a class=post-dummy-target id=均摊时间复杂度></a><h4>均摊时间复杂度</h4><p>当i &lt; len时, 即 i = 0,1,2,&hellip;,n-1的时候，for循环不走，所以这n次的时间复杂度都是O(1);
当i &gt;= len时, 即 i = n的时候，for循环进行数组的copy，所以只有这1次的时间复杂度是O(n);
由此可知:
该算法的最好情况时间复杂度(best case time complexity)为O(1);
最坏情况时间复杂度(worst case time complexity)为O(n);
平均情况时间复杂度(average case time complexity),
第一种计算方式: (1+1+&hellip;+1+n)/(n+1) = 2n/(n+1) 【注: 式子中1+1+&hellip;+1中有n个1】,所以平均复杂度为O(1);
第二种计算方式(加权平均法，又称期望): 1<em>(1/n+1)+1</em>(1/n+1)+&hellip;+1<em>(1/n+1)+n</em>(1/(n+1))=1，所以加权平均时间复杂度为O(1);
第三种计算方式(均摊时间复杂度): 前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)</p><a class=post-dummy-target id=数组-array></a><h2>数组 Array</h2><blockquote><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p></blockquote><p><strong>线性表</strong></p><p>数组,链表,栈,队列皆为线性表.</p><p><strong>非线性表</strong></p><p>二叉树,堆,图</p><a class=post-dummy-target id=如何实现随机访问></a><h4>如何实现随机访问?</h4><p>首先是个 <strong>线性表</strong>,其次是拥有 <strong>连续的存储空间和相同的数据类型</strong>.</p><a class=post-dummy-target id=数组为何适合查找></a><h4>数组为何适合查找?</h4><p><strong>数组支持随机访问,根据下标随机访问的时间复杂度为 O(1).</strong> 如果排好序的数组通过二分查找,那就是 O(logn)了,所以需要注意根据下标随机访问的条件.</p><a class=post-dummy-target id=为什么数组要从0开始编号-而不是-1></a><h4>为什么数组要从0开始编号,而不是 1?</h4><p>数组的下标其实是其在内存中的偏移(offset)倍数</p><p>为0时计算公式通常为: <code>a[k]_address = base_address + k * type_size</code>.</p><p>为1时计算公式通常为: <code>a[k]_address = base_address + (k-1)*type_size</code></p><p>对于 CPU 来说为 0 时减少了一次 <strong>减法</strong> 操作.</p><a class=post-dummy-target id=二维数组如何寻址></a><h4>二维数组如何寻址?</h4><p>对于 m * n 的数组，<code>a [ i ][ j ]</code> (i &lt; m,j &lt; n)的地址为：<code>address = base_address + ( i * n + j) * type_size</code></p><a class=post-dummy-target id=链表></a><h2>链表</h2><p><strong>空间换时间</strong>,<strong>时间换空间</strong></p><a class=post-dummy-target id=链表与数组的区别></a><h4>链表与数组的区别?</h4><ol><li>数组分配内存连续,可以借助 CPU 高速缓存预读数据,访问效率更高.链表就不行.</li><li>数组需要占据一块连续的内存,没有足够空间就会导致 <code>OOM</code>.链表无所谓,动态扩容,有地儿就能塞进去.</li></ol><a class=post-dummy-target id=实现一个-lru></a><h4>实现一个 LRU?</h4><blockquote><p><a href=https://www.journaldev.com/32688/lru-cache-implementation-in-java>https://www.journaldev.com/32688/lru-cache-implementation-in-java</a></p></blockquote><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<ol><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ol></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 0001-01-01 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://xiaohei.im/1/01/01/posts/datastruturealgorithm/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://xiaohei.im/>主页</a></span></section></div><div class=post-nav><a href=https://xiaohei.im/1/01/01/posts/linkedlist/ class=prev rel=prev><i class="fas fa-angle-left fa-fw"></i></a><a href=https://xiaohei.im/1/01/01/posts/array/ class=next rel=next><i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"0001-01-01 00:00:00 \x2b0000 UTC",title:"",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xiaohei.im/>xiaoheiAh</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>