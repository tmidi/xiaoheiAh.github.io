<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Redis-数据结构 | xiaohei&#39;s blog | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content=赵小黑的各种记录><link rel=prev href=https://xiaohei.im/2019/10/23/posts/rabbitmq-ack-confirm/><link rel=next href=https://xiaohei.im/2019/11/03/posts/distributed-lock/><link rel=canonical href=https://xiaohei.im/2019/10/24/posts/data-structure/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content=Redis-数据结构><meta name=twitter:description content="系统学习 redis 相关的知识，从数据结构开始～"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Redis-数据结构","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xiaohei.im\/2019\/10\/24\/posts\/data-structure\/"},"image":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/cover.png","width":800,"height":600},"genre":"posts","keywords":"redis, 数据结构","wordcount":6967,"url":"https:\/\/xiaohei.im\/2019\/10\/24\/posts\/data-structure\/","datePublished":"2019-10-24T09:59:11\x2b08:00","dateModified":"2019-10-24T09:59:11\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX">Redis-数据结构</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://xiaohei.im/ rel=author><i class="fas fa-user-circle fa-fw"></i>xiaoheiAh&nbsp;</a>
<span class=post-category>收录于
<i class="far fa-folder fa-fw"></i><a href=https://xiaohei.im/categories/redis/>redis</a></span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-10-24>2019-10-24</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 6967 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 14 分钟&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#string-字符串>String 字符串</a><ul><li><a href=#常用命令>常用命令</a></li><li><a href=#结构>结构</a></li><li><a href=#字符串存储>字符串存储</a><ul><li><a href=#why>WHY?</a></li></ul></li></ul></li><li><a href=#list-列表>List 列表</a><ul><li><a href=#常用命令-1>常用命令</a></li><li><a href=#列表的数据结构>列表的数据结构</a><ul><li><a href=#ziplist-压缩列表>ziplist 压缩列表</a><ul><li><a href=#encoding-编码类型>encoding 编码类型</a></li><li><a href=#增加元素>增加元素</a></li><li><a href=#级联更新>级联更新</a></li></ul></li><li><a href=#quicklist>quicklist</a><ul><li><a href=#一张图展示结构>一张图展示结构</a></li><li><a href=#压缩深度>压缩深度</a></li></ul></li></ul></li></ul></li><li><a href=#set-集合>Set 集合</a><ul><li><a href=#常用命令-2>常用命令</a></li></ul></li><li><a href=#hash-哈希>Hash 哈希</a><ul><li><a href=#常用命令-3>常用命令</a></li><li><a href=#字典>字典</a><ul><li><a href=#struct>struct</a></li><li><a href=#一张图来表示>一张图来表示</a></li><li><a href=#何时扩容>何时扩容?</a></li><li><a href=#何时缩容>何时缩容?</a></li><li><a href=#渐进式-rehash>渐进式 rehash</a><ul><li><a href=#增删改查辅助rehash>增删改查辅助rehash</a></li><li><a href=#后台任务rehash>后台任务rehash</a></li></ul></li><li><a href=#渐进式rehash弊端>渐进式rehash弊端</a></li></ul></li></ul></li><li><a href=#zset-有序集合>Zset 有序集合</a><ul><li><a href=#常用命令-4>常用命令</a></li><li><a href=#数据结构>数据结构</a><ul><li><a href=#什么是跳跃列表>什么是跳跃列表?</a></li><li><a href=#struct-1>struct</a></li><li><a href=#redis中跳表的优化>redis中跳表的优化</a></li><li><a href=#一次查找的过程>一次查找的过程</a></li><li><a href=#redis中level是如何生成的>redis中level是如何生成的?</a></li><li><a href=#为什么使用跳表而不是红黑树或者哈希表>为什么使用跳表而不是红黑树或者哈希表?</a></li></ul></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>目录</span><span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#string-字符串>String 字符串</a><ul><li><a href=#常用命令>常用命令</a></li><li><a href=#结构>结构</a></li><li><a href=#字符串存储>字符串存储</a><ul><li><a href=#why>WHY?</a></li></ul></li></ul></li><li><a href=#list-列表>List 列表</a><ul><li><a href=#常用命令-1>常用命令</a></li><li><a href=#列表的数据结构>列表的数据结构</a><ul><li><a href=#ziplist-压缩列表>ziplist 压缩列表</a><ul><li><a href=#encoding-编码类型>encoding 编码类型</a></li><li><a href=#增加元素>增加元素</a></li><li><a href=#级联更新>级联更新</a></li></ul></li><li><a href=#quicklist>quicklist</a><ul><li><a href=#一张图展示结构>一张图展示结构</a></li><li><a href=#压缩深度>压缩深度</a></li></ul></li></ul></li></ul></li><li><a href=#set-集合>Set 集合</a><ul><li><a href=#常用命令-2>常用命令</a></li></ul></li><li><a href=#hash-哈希>Hash 哈希</a><ul><li><a href=#常用命令-3>常用命令</a></li><li><a href=#字典>字典</a><ul><li><a href=#struct>struct</a></li><li><a href=#一张图来表示>一张图来表示</a></li><li><a href=#何时扩容>何时扩容?</a></li><li><a href=#何时缩容>何时缩容?</a></li><li><a href=#渐进式-rehash>渐进式 rehash</a><ul><li><a href=#增删改查辅助rehash>增删改查辅助rehash</a></li><li><a href=#后台任务rehash>后台任务rehash</a></li></ul></li><li><a href=#渐进式rehash弊端>渐进式rehash弊端</a></li></ul></li></ul></li><li><a href=#zset-有序集合>Zset 有序集合</a><ul><li><a href=#常用命令-4>常用命令</a></li><li><a href=#数据结构>数据结构</a><ul><li><a href=#什么是跳跃列表>什么是跳跃列表?</a></li><li><a href=#struct-1>struct</a></li><li><a href=#redis中跳表的优化>redis中跳表的优化</a></li><li><a href=#一次查找的过程>一次查找的过程</a></li><li><a href=#redis中level是如何生成的>redis中level是如何生成的?</a></li><li><a href=#为什么使用跳表而不是红黑树或者哈希表>为什么使用跳表而不是红黑树或者哈希表?</a></li></ul></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>系统学习 redis 相关的知识，从数据结构开始～</p><a class=post-dummy-target id=string-字符串></a><h2>String 字符串</h2><p>Redis 的字符串是 <strong>动态字符串</strong>, 长度可变，自动扩容。利用预分配空间方式减少内存的分配。默认分配 1M 大小的内存。扩容时加倍现有空间，最大占用为 <code>512M</code>.</p><a class=post-dummy-target id=常用命令></a><h3>常用命令</h3><p><a href=https://redis.io/commands/set>SET</a>,<a href=https://redis.io/commands/setnx>SETNX</a>&hellip;</p><a class=post-dummy-target id=结构></a><h3>结构</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>SDS</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=n>T</span> <span class=n>capacity</span><span class=p>;</span> <span class=c1>// 数组容量
</span><span class=c1></span>  <span class=n>T</span> <span class=n>len</span><span class=p>;</span> <span class=c1>// 数组长度
</span><span class=c1></span>  <span class=n>byte</span> <span class=n>flags</span><span class=p>;</span> <span class=c1>// 特殊标识位，不理睬它
</span><span class=c1></span>  <span class=n>byte</span> <span class=p>[]</span> <span class=n>content</span><span class=p>;</span> <span class=c1>// 数组内容
</span><span class=c1></span><span class=p>}</span></code></pre></td></tr></table></div></div><p>Redis 中的字符串叫做 <code>Simple Dynamic String</code>, 上述 <code>struct</code> 是一个简化版，实际的代码中，redis 会根据 str 的不同长度，使用不同的 <code>SDS</code>, 有 <code>sdshdr8</code>, <code>sdshdr16</code>, <code>sdshdr32</code> 等等&hellip; 但结构体都是如上的类型.</p><p><code>capacity</code> 存储数组的长度，<code>len</code> 表示数组的实际长度。需要注意的是: string 的字符串是以 <code>\0</code> 结尾的，这样可以便于调试打印，还可以直接使用 <code>glibc</code> 的字符串函数进行操作.</p><a class=post-dummy-target id=字符串存储></a><h3>字符串存储</h3><p>字符串有两种存储方式，长度很短时，使用 <code>emb</code> 形式存储，长度超过 <code>44</code> 时，使用 <code>raw</code> 形式存储.</p><p>可以使用 <code>debug object {your_string}</code> 来查看存储形式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>&gt; <span class=nb>set</span> codehole abcdefghijklmnopqrstuvwxyz012345678912345678
OK
&gt; debug object codehole
Value at:0x7fec2de00370 refcount:1 encoding:embstr serializedlength:45 lru:5958906 lru_seconds_idle:1
&gt; <span class=nb>set</span> codehole abcdefghijklmnopqrstuvwxyz0123456789123456789
OK
&gt; debug object codehole
Value at:0x7fec2dd0b750 refcount:1 encoding:raw serializedlength:46 lru:5958911 lru_seconds_idle:1</code></pre></td></tr></table></div></div><a class=post-dummy-target id=why></a><h4>WHY?</h4><p>首先需要解释 <code>RedisObject</code>, 所有 Redis 对象都有的结构体</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>RedisObject</span> <span class=p>{</span>
    <span class=n>int4</span> <span class=n>type</span><span class=p>;</span> <span class=c1>// 4bits
</span><span class=c1></span>    <span class=n>int4</span> <span class=n>encoding</span><span class=p>;</span> <span class=c1>// 4bits
</span><span class=c1></span>    <span class=n>int24</span> <span class=n>lru</span><span class=p>;</span> <span class=c1>// 24bits
</span><span class=c1></span>    <span class=n>int32</span> <span class=n>refcount</span><span class=p>;</span> <span class=c1>// 4bytes
</span><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span> <span class=c1>// 8bytes，64-bit system
</span><span class=c1></span><span class=p>}</span> <span class=n>robj</span><span class=p>;</span></code></pre></td></tr></table></div></div><p>不同的对象具有不同的类型 <code>type (4bit)</code>，同一个类型的 type 会有不同的存储形式 <code>encoding (4bit)</code>，为了记录对象的 LRU 信息，使用了 24 个 bit 来记录 LRU 信息。每个对象都有个引用计数，当引用计数为零时，对象就会被销毁，内存被回收。<code>ptr</code> 指针将指向对象内容 (body) 的具体存储位置。这样一个 RedisObject 对象头需要占据 16 字节的存储空间。</p><p>接着我们再看 SDS 结构体的大小，在字符串比较小时，SDS 对象头的大小是 <code>capacity+3</code>，至少是 3。意味着分配一个字符串的最小空间占用为 19 字节 (16+3)。</p><p>一张图解释:</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191028154142.png alt=sds class=lazyload><figcaption class=image-caption>sds</figcaption></figure></p><a class=post-dummy-target id=list-列表></a><h2>List 列表</h2><p>Redis 的列表是用链表来实现的，插入删除 <code>O (1)</code>, 查找 <code>O (n)</code>, 列表弹出最后一个元素时，数据结构删除，内存回收.</p><a class=post-dummy-target id=常用命令-1></a><h3>常用命令</h3><p><a href=https://redis.io/commands/lpush>LPUSH</a>,<a href=https://redis.io/commands/lpop>LPOP</a>,<a href=https://redis.io/commands/rpush>RPUSH</a>,<a href=https://redis.io/commands/rpop>RPOP</a>,<a href=https://redis.io/commands/lrange>LRANGE</a>&hellip;</p><a class=post-dummy-target id=列表的数据结构></a><h3>列表的数据结构</h3><p>列表底层的存储结构并不是简简单单的一个链表～通过 <code>ziplist</code> 连接起来组成 <code>quicklist</code>.</p><a class=post-dummy-target id=ziplist-压缩列表></a><h4>ziplist 压缩列表</h4><p>在列表元素较少时，redis 会使用一块连续内存来进行存储，这个结构就是 <code>ziplist</code>. 所有的元素紧挨着存储.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>&gt; zadd z_lang <span class=m>1</span> java <span class=m>2</span> rust <span class=m>3</span> go
<span class=o>(</span>integer<span class=o>)</span> <span class=m>3</span>
&gt; debug object z_lang
Value at:0x7fde1c466660 refcount:1 encoding:ziplist serializedlength:34 lru:11974320 lru_seconds_idle:11</code></pre></td></tr></table></div></div><p>可以看到上述输出 <code>encoding</code> 为 <code>ziplist</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>ziplist</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=n>int32</span> <span class=n>zlbytes</span><span class=p>;</span> <span class=c1>// 整个压缩列表占用字节数
</span><span class=c1></span>    <span class=n>int32</span> <span class=n>zltail_offset</span><span class=p>;</span> <span class=c1>// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
</span><span class=c1></span>    <span class=n>int16</span> <span class=n>zllength</span><span class=p>;</span> <span class=c1>// 元素个数
</span><span class=c1></span>    <span class=n>T</span> <span class=p>[]</span> <span class=n>entries</span><span class=p>;</span> <span class=c1>// 元素内容列表，挨个挨个紧凑存储
</span><span class=c1></span>    <span class=n>int8</span> <span class=n>zlend</span><span class=p>;</span> <span class=c1>// 标志压缩列表的结束，值恒为 0xFF
</span><span class=c1></span><span class=p>}</span></code></pre></td></tr></table></div></div><p><code>zltail_offset</code> 是为了支持双向遍历才设计的，可以快速定位到最后一个元素，然后倒着遍历.</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191028174656.png alt=ziplist结构 class=lazyload><figcaption class=image-caption>ziplist结构</figcaption></figure></p><p><code>entry</code> 会随着容纳的元素不同而结构不同.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>entry</span> <span class=p>{</span>
    <span class=kt>int</span><span class=o>&lt;</span><span class=n>var</span><span class=o>&gt;</span> <span class=n>prevlen</span><span class=p>;</span> <span class=c1>// 前一个 entry 的字节长度
</span><span class=c1></span>    <span class=kt>int</span><span class=o>&lt;</span><span class=n>var</span><span class=o>&gt;</span> <span class=n>encoding</span><span class=p>;</span> <span class=c1>// 元素类型编码
</span><span class=c1></span>    <span class=n>optional</span> <span class=n>byte</span> <span class=p>[]</span> <span class=n>content</span><span class=p>;</span> <span class=c1>// 元素内容
</span><span class=c1></span><span class=p>}</span></code></pre></td></tr></table></div></div><p><code>prevlen</code> 表示前一个 entry 的字节长度，倒序遍历时，可以根据这个字段来推算前一个 entry 的位置。它是变长的整数，字符串长度小于 254 ( <code>0XFE</code> ) 时，使用一个字节表示，大于等于 254, 使用 5 个字节来表示。第一个字节是 254, 剩余四个字节表示字符串长度.</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191028175143.png alt=ziplist-entry class=lazyload><figcaption class=image-caption>ziplist-entry</figcaption></figure></p><a class=post-dummy-target id=encoding-编码类型></a><h5>encoding 编码类型</h5><p><code>encoding</code> 存储编码类型信息，<code>ziplist</code> 通过其来决定 <code>content</code> 内容的形式。所以其设计是很复杂的.</p><ol><li><code>00xxxxxx</code> 最大长度位 63 的短字符串，后面的 6 个位存储字符串的位数，剩余的字节就是字符串的内容。</li><li><code>01xxxxxx xxxxxxxx</code> 中等长度的字符串，后面 14 个位来表示字符串的长度，剩余的字节就是字符串的内容。</li><li><code>10000000 aaaaaaaa bbbbbbbb cccccccc dddddddd</code> 特大字符串，需要使用额外 4 个字节来表示长度。第一个字节前缀是 <code>10</code>，剩余 6 位没有使用，统一置为零。后面跟着字符串内容。不过这样的大字符串是没有机会使用的，压缩列表通常只是用来存储小数据的。</li><li><code>11000000</code> 表示 int16，后跟两个字节表示整数。</li><li><code>11010000</code> 表示 int32，后跟四个字节表示整数。</li><li><code>11100000</code> 表示 int64，后跟八个字节表示整数。</li><li><code>11110000</code> 表示 int24，后跟三个字节表示整数。</li><li><code>11111110</code> 表示 int8，后跟一个字节表示整数。</li><li><code>11111111</code> 表示 ziplist 的结束，也就是 zlend 的值 0xFF。</li><li><code>1111xxxx</code> 表示极小整数，xxxx 的范围只能是 (<code>0001~1101</code>), 也就是 <code>1~13</code>，因为 <code>0000、1110、1111</code> 都被占用了。读取到的 value 需要将 xxxx 减 1，也就是整数 <code>0~12</code> 就是最终的 value。</li></ol><a class=post-dummy-target id=增加元素></a><h5>增加元素</h5><p><code>ziplist</code> 是连续存储的，没有多余空间，这意味着每次插入一个元素，就需要扩展内存。如果占用内存过大，重新分配内存和拷贝内存就会有很大的消耗。所以其缺点是不适合存储 <strong>大型字符串</strong>, 存储元素不宜 <strong>过多</strong>.</p><a class=post-dummy-target id=级联更新></a><h5>级联更新</h5><p>每一个 entry 都是有 <code>prevlen</code>, 而且时而为 1 字节存储，时而为 5 字节存储，取决于字符串的字节长度是否大于 <strong>254</strong>, 如果某次操作导致字节长度从 254 变为 256, 那么其下一个节点所存储的 <code>prevlen</code> 就要从 1 个字节变为 5 个字节来存储，如果下一个节点刚好因此超过了 254 的长度，那么下下个节点也要更新&hellip; 这就是级联更新了～</p><a class=post-dummy-target id=quicklist></a><h4>quicklist</h4><p>Redis 中 list 的存储结构就是 <code>quicklist</code>. 下面的 language 是一个记录编程语言的集合。可以看到 <code>encoding</code> 即为 <code>quicklist</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>&gt; debug object language
Value at:0x7fde1c4665f0 refcount:1 encoding:quicklist serializedlength:29 lru:11974264 lru_seconds_idle:62740 ql_nodes:1 ql_avg_node:3.00 ql_ziplist_max:-2 ql_compressed:0 ql_uncompressed_size:27</code></pre></td></tr></table></div></div><p>Redis 的 <code>quicklist</code> 是一种基于 <code>ziplist</code> 实现的可压缩（<code>quicklistLZF</code>）的双向链表，结合了链表和 ziplist 的 <code>优点</code> 组成的。下面可以看下他的结构体.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
</span><span class=cm> * &#39;count&#39; is the number of total entries.
</span><span class=cm> * &#39;len&#39; is the number of quicklist nodes.
</span><span class=cm> * &#39;compress&#39; is: -1 if compression disabled, otherwise it&#39;s the number
</span><span class=cm> *                of quicklistNodes to leave uncompressed at ends of quicklist.
</span><span class=cm> * &#39;fill&#39; is the user-requested (or default) fill factor. */</span>
<span class=cm>/**
</span><span class=cm> * quicklist 是一个 40byte (64 位系统) 的结构
</span><span class=cm> */</span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklist</span> <span class=p>{</span>
    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>
    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>count</span><span class=p>;</span>        <span class=cm>/* 元素总数 */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>len</span><span class=p>;</span>          <span class=cm>/* quicklistNode 的长度 */</span>
    <span class=kt>int</span> <span class=nl>fill</span> <span class=p>:</span> <span class=mi>16</span><span class=p>;</span>              <span class=cm>/* ziplist 的最大长度 */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>compress</span> <span class=p>:</span> <span class=mi>16</span><span class=p>;</span> <span class=cm>/* 节点压缩深度 */</span>
<span class=p>}</span> <span class=n>quicklist</span><span class=p>;</span>

<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>zl</span><span class=p>;</span> <span class=cm>/* 没有压缩，指向 ziplist, 否则指向 quicklistLZF
</span><span class=cm>    unsigned int sz;   /* ziplist 字节总数 */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>count</span> <span class=p>:</span> <span class=mi>16</span><span class=p>;</span>     <span class=cm>/* ziplist 元素数量 */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>encoding</span> <span class=p>:</span> <span class=mi>2</span><span class=p>;</span>   <span class=cm>/* RAW==1 or LZF==2 */</span>
		<span class=p>...</span>
<span class=p>}</span> <span class=n>quicklistNode</span><span class=p>;</span>

<span class=c1>//LZF 无损压缩算法，压缩过的 ziplist
</span><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistLZF</span> <span class=p>{</span>
    <span class=c1>// 未压缩之前的大小
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span> <span class=cm>/* LZF size in bytes*/</span>
    <span class=c1>// 存放压缩过的 ziplist 数组
</span><span class=c1></span>    <span class=kt>char</span> <span class=n>compressed</span> <span class=p>[];</span>
<span class=p>}</span> <span class=n>quicklistLZF</span><span class=p>;</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=一张图展示结构></a><h5>一张图展示结构</h5><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191029112957.png alt=quicklist class=lazyload><figcaption class=image-caption>quicklist</figcaption></figure></p><a class=post-dummy-target id=压缩深度></a><h5>压缩深度</h5><p><code>quicklist</code> 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 <code>list-compress-depth</code> 决定。为了支持快速的 push/pop 操作，<code>quicklist</code> 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><a class=post-dummy-target id=set-集合></a><h2>Set 集合</h2><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值<code>NULL</code>。</p><a class=post-dummy-target id=常用命令-2></a><h3>常用命令</h3><p><a href=https://redis.io/commands/sadd>SADD</a>,<a href=https://redis.io/commands/smembers>SMEMBERS</a>,<a href=https://redis.io/commands/spop>SPOP</a>,<a href=https://redis.io/commands/sismember>SISMEMBER</a>,<a href=https://redis.io/commands/scard>SCARD</a>&hellip;</p><a class=post-dummy-target id=hash-哈希></a><h2>Hash 哈希</h2><p>Redis 的 Hash相当于Java 中的 HashMap, 数组 + 链表的二维结构.与 HashMap 不同的地方在于 <code>rehash</code> 方式不同, HashMap 中的 <code>rehash</code> 是阻塞式的, 需要一次性全部 <code>rehash</code>, 而 redis 为了性能考虑, 采用的是 <code>渐进式 rehash</code>.</p><a class=post-dummy-target id=常用命令-3></a><h3>常用命令</h3><p><a href=https://redis.io/commands/hset>HSET</a>,<a href=https://redis.io/commands/hget>HGET</a>,<a href=https://redis.io/commands/hmset>HMSET</a>,<a href=https://redis.io/commands/hlen>HLEN</a>&hellip;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>&gt; hset books java <span class=s2>&#34;think in java&#34;</span>  <span class=c1># 命令行的字符串如果包含空格，要用引号括起来</span>
<span class=o>(</span>integer<span class=o>)</span> <span class=m>1</span>
&gt; hset books golang <span class=s2>&#34;concurrency in go&#34;</span>
<span class=o>(</span>integer<span class=o>)</span> <span class=m>1</span>
&gt; hset books python <span class=s2>&#34;python cookbook&#34;</span>
<span class=o>(</span>integer<span class=o>)</span> <span class=m>1</span>
&gt; hgetall books  <span class=c1># entries()，key 和 value 间隔出现</span>
<span class=m>1</span><span class=o>)</span> <span class=s2>&#34;java&#34;</span>
<span class=m>2</span><span class=o>)</span> <span class=s2>&#34;think in java&#34;</span>
<span class=m>3</span><span class=o>)</span> <span class=s2>&#34;golang&#34;</span>
<span class=m>4</span><span class=o>)</span> <span class=s2>&#34;concurrency in go&#34;</span>
<span class=m>5</span><span class=o>)</span> <span class=s2>&#34;python&#34;</span>
<span class=m>6</span><span class=o>)</span> <span class=s2>&#34;python cookbook&#34;</span>
&gt; hlen books
<span class=o>(</span>integer<span class=o>)</span> <span class=m>3</span>
&gt; hget books java
<span class=s2>&#34;think in java&#34;</span>
&gt; hset books golang <span class=s2>&#34;learning go programming&#34;</span>  <span class=c1># 因为是更新操作，所以返回 0</span>
<span class=o>(</span>integer<span class=o>)</span> <span class=m>0</span>
&gt; hget books golang
<span class=s2>&#34;learning go programming&#34;</span>
&gt; hmset books java <span class=s2>&#34;effective java&#34;</span> python <span class=s2>&#34;learning python&#34;</span> golang <span class=s2>&#34;modern golang programming&#34;</span>  <span class=c1># 批量 set</span>
OK</code></pre></td></tr></table></div></div><a class=post-dummy-target id=字典></a><h3>字典</h3><p>Redis 的 Hash 是通过 <code>dict</code> 结构来实现的, 该结构的底层是由哈希表来实现.类似于 HashMap, 数组+链表, 超过负载因子所对应的阈值时,进行 <code>rehash</code>, 扩容. 在具体实现中,使用了渐进式hash的方式来避免 HashMap 这种阻塞式的 rehash, 将 rehash 的工作分摊到对字典的增删改查中.</p><a class=post-dummy-target id=struct></a><h4>struct</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>dictEntry</span> <span class=p>{</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>;</span> <span class=c1>//键
</span><span class=c1></span>    <span class=k>union</span> <span class=p>{</span>
        <span class=kt>void</span> <span class=o>*</span><span class=n>val</span><span class=p>;</span>  <span class=c1>//值
</span><span class=c1></span>        <span class=n>uint64_t</span> <span class=n>u64</span><span class=p>;</span>
        <span class=n>int64_t</span> <span class=n>s64</span><span class=p>;</span>
        <span class=kt>double</span> <span class=n>d</span><span class=p>;</span>
    <span class=p>}</span> <span class=n>v</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>dictEntry</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span> <span class=c1>//指向下一节点,形成链表
</span><span class=c1></span><span class=p>}</span> <span class=n>dictEntry</span><span class=p>;</span>

<span class=cm>/* This is our hash table structure. Every dictionary has two of this as we
</span><span class=cm> * implement incremental rehashing, for the old to the new table. */</span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=n>dictht</span> <span class=p>{</span>
    <span class=n>dictEntry</span> <span class=o>**</span><span class=n>table</span><span class=p>;</span> <span class=c1>// 哈希表数组,数组的每一项都是 distEntry 的头结点
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// 哈希表的大小,也是触发扩容的阈值
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>sizemask</span><span class=p>;</span> <span class=c1>// 哈希表大小掩码,用于计算索引值,总是等于 size-1
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>used</span><span class=p>;</span> <span class=c1>// 哈希表中实际保存的节点数量
</span><span class=c1></span><span class=p>}</span> <span class=n>dictht</span><span class=p>;</span>

<span class=k>typedef</span> <span class=k>struct</span> <span class=n>dict</span> <span class=p>{</span>
    <span class=n>dictType</span> <span class=o>*</span><span class=n>type</span><span class=p>;</span> <span class=c1>//属性是一个指向 dictType 结构的指针,每个 dictType 结构保存了一簇用于操作特定类型键值对的函数,Redis 会为用途不同的字典设置不同的类型特定函数
</span><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>privdata</span><span class=p>;</span> <span class=c1>// 保存了需要传给那些类型特定函数的可选参数
</span><span class=c1></span>    <span class=n>dictht</span> <span class=n>ht</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span> <span class=c1>// 在字典内部,维护了两张哈希表. 一般情况下,字典只使用 ht[0] 哈希表,ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用
</span><span class=c1></span>    <span class=kt>long</span> <span class=n>rehashidx</span><span class=p>;</span> <span class=c1>// 记录 rehash 的状态, 没有进行 rehash 则为 -1
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>iterators</span><span class=p>;</span> <span class=cm>/* number of iterators currently running */</span>
<span class=p>}</span> <span class=n>dict</span><span class=p>;</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=一张图来表示></a><h4>一张图来表示</h4><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191103120536.png alt=图片来自美团技术博客 class=lazyload><figcaption class=image-caption>图片来自美团技术博客</figcaption></figure></p><a class=post-dummy-target id=何时扩容></a><h4>何时扩容?</h4><p>找到<code>dictAddRow</code> 函数观察源码可以发现,会在 <code>_dictExpandIfNeeded</code> 函数中进行扩容的判断.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* Expand the hash table if needed */</span>
<span class=k>static</span> <span class=kt>int</span> <span class=nf>_dictExpandIfNeeded</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>d</span><span class=p>)</span>
<span class=p>{</span>
    <span class=cm>/* Incremental rehashing already in progress. Return. */</span>
  	<span class=c1>// 正在渐进式扩容, 就返回 OK
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>dictIsRehashing</span><span class=p>(</span><span class=n>d</span><span class=p>))</span> <span class=k>return</span> <span class=n>DICT_OK</span><span class=p>;</span>

    <span class=cm>/* If the hash table is empty expand it to the initial size. */</span>
  	<span class=c1>// 如果哈希表 ht[0] size 为 0 ,初始化, 说明 redis 是懒加载的,延长初始化策略
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>dictExpand</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=n>DICT_HT_INITIAL_SIZE</span><span class=p>);</span>

    <span class=cm>/* If we reached the 1:1 ratio, and we are allowed to resize the hash
</span><span class=cm>     * table (global setting) or we should avoid it but the ratio between
</span><span class=cm>     * elements/buckets is over the &#34;safe&#34; threshold, we resize doubling
</span><span class=cm>     * the number of buckets. */</span>
    <span class=cm>/*
</span><span class=cm>     * 如果哈希表ht[0]中保存的key个数与哈希表大小的比例已经达到1:1，即保存的节点数已经大于哈希表大小
</span><span class=cm>     * 且redis服务当前允许执行rehash，或者保存的节点数与哈希表大小的比例超过了安全阈值（默认值为5）
</span><span class=cm>     * 则将哈希表大小扩容为原来的两倍
</span><span class=cm>     */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>used</span> <span class=o>&gt;=</span> <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span> <span class=o>&amp;&amp;</span>
        <span class=p>(</span><span class=n>dict_can_resize</span> <span class=o>||</span>
         <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>used</span><span class=o>/</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>dict_force_resize_ratio</span><span class=p>))</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=n>dictExpand</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>used</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>DICT_OK</span><span class=p>;</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>正常情况下，当 hash 表中元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是原数组大小的 2 倍。不过如果 Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容 (<code>dict_can_resize</code>)，但是如果 hash 表已经非常满了，元素的个数已经达到了第一维数组长度的 5 倍 (<code>dict_force_resize_ratio</code>)，说明 hash 表已经过于拥挤了，这个时候就会强制扩容。</p><a class=post-dummy-target id=何时缩容></a><h4>何时缩容?</h4><p>当哈希表的负载因子小于 0.1 时,自动缩容.这个操作会在 redis 的定时任务中来完成.函数为 <code>databasesCron</code>,该函数的作用是在后台慢慢的处理过期,<code>rehashing</code>, 缩容.</p><p><strong>执行条件:</strong> 没有子进程执行aof重写或者生成RDB文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* 遍历所有的redis数据库,尝试缩容 */</span>
<span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>dbs_per_call</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>tryResizeHashTables</span><span class=p>(</span><span class=n>resize_db</span> <span class=o>%</span> <span class=n>server</span><span class=p>.</span><span class=n>dbnum</span><span class=p>);</span>
  <span class=n>resize_db</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span>
<span class=cm>/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL
</span><span class=cm> * we resize the hash table to save memory */</span>
<span class=kt>void</span> <span class=n>tryResizeHashTables</span><span class=p>(</span><span class=kt>int</span> <span class=n>dbid</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>htNeedsResize</span><span class=p>(</span><span class=n>server</span><span class=p>.</span><span class=n>db</span><span class=p>[</span><span class=n>dbid</span><span class=p>].</span><span class=n>dict</span><span class=p>))</span>
        <span class=n>dictResize</span><span class=p>(</span><span class=n>server</span><span class=p>.</span><span class=n>db</span><span class=p>[</span><span class=n>dbid</span><span class=p>].</span><span class=n>dict</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>htNeedsResize</span><span class=p>(</span><span class=n>server</span><span class=p>.</span><span class=n>db</span><span class=p>[</span><span class=n>dbid</span><span class=p>].</span><span class=n>expires</span><span class=p>))</span>
        <span class=n>dictResize</span><span class=p>(</span><span class=n>server</span><span class=p>.</span><span class=n>db</span><span class=p>[</span><span class=n>dbid</span><span class=p>].</span><span class=n>expires</span><span class=p>);</span>
<span class=p>}</span>
<span class=cm>/* Hash table parameters */</span>
<span class=cp>#define HASHTABLE_MIN_FILL        10      </span><span class=cm>/* Minimal hash table fill 10% */</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=n>htNeedsResize</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>dict</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>long</span> <span class=kt>long</span> <span class=n>size</span><span class=p>,</span> <span class=n>used</span><span class=p>;</span>

    <span class=n>size</span> <span class=o>=</span> <span class=n>dictSlots</span><span class=p>(</span><span class=n>dict</span><span class=p>);</span>
    <span class=n>used</span> <span class=o>=</span> <span class=n>dictSize</span><span class=p>(</span><span class=n>dict</span><span class=p>);</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>DICT_HT_INITIAL_SIZE</span> <span class=o>&amp;&amp;</span>
            <span class=p>(</span><span class=n>used</span><span class=o>*</span><span class=mi>100</span><span class=o>/</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>HASHTABLE_MIN_FILL</span><span class=p>));</span>
<span class=p>}</span>
<span class=cm>/* Resize the table to the minimal size that contains all the elements,
</span><span class=cm> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span>
<span class=kt>int</span> <span class=n>dictResize</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>d</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>minimal</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>dict_can_resize</span> <span class=o>||</span> <span class=n>dictIsRehashing</span><span class=p>(</span><span class=n>d</span><span class=p>))</span> <span class=k>return</span> <span class=n>DICT_ERR</span><span class=p>;</span>
    <span class=n>minimal</span> <span class=o>=</span> <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>used</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>minimal</span> <span class=o>&lt;</span> <span class=n>DICT_HT_INITIAL_SIZE</span><span class=p>)</span>
        <span class=n>minimal</span> <span class=o>=</span> <span class=n>DICT_HT_INITIAL_SIZE</span><span class=p>;</span>
    <span class=k>return</span> <span class=nf>dictExpand</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=n>minimal</span><span class=p>);</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>从 <code>htNeedsResize</code>函数中可以看到,当哈希表保存的key数量与哈希表的大小的比例小于10%时需要缩容.最小容量为<code>DICT_HT_INITIAL_SIZE = 4</code>. <code>dictResize</code> 函数中,当正在执行 aof 重写或生成 rdb 时, <code>dict_can_resize</code> 会变为 0, 也就说明上面的 <strong>执行条件</strong>.</p><a class=post-dummy-target id=渐进式-rehash></a><h4>渐进式 rehash</h4><p>从上述源码中可以看出,所有的扩容或者创建都经过 <code>dictExpand</code> 函数.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* Expand or create the hash table */</span>
<span class=kt>int</span> <span class=nf>dictExpand</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>d</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>size</span><span class=p>)</span>
<span class=p>{</span>
    <span class=cm>/* the size is invalid if it is smaller than the number of
</span><span class=cm>     * elements already inside the hash table */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>dictIsRehashing</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=o>||</span> <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>used</span> <span class=o>&gt;</span> <span class=n>size</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>DICT_ERR</span><span class=p>;</span>
		<span class=c1>// 计算新的哈希表大小,获得大于等于size的第一个2次方
</span><span class=c1></span>    <span class=n>dictht</span> <span class=n>n</span><span class=p>;</span> <span class=cm>/* the new hash table */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>realsize</span> <span class=o>=</span> <span class=n>_dictNextPower</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>

    <span class=cm>/* Rehashing to the same table size is not useful. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>realsize</span> <span class=o>==</span> <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span><span class=p>)</span> <span class=k>return</span> <span class=n>DICT_ERR</span><span class=p>;</span>

    <span class=cm>/* Allocate the new hash table and initialize all pointers to NULL */</span>
    <span class=n>n</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>realsize</span><span class=p>;</span>
    <span class=n>n</span><span class=p>.</span><span class=n>sizemask</span> <span class=o>=</span> <span class=n>realsize</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=n>n</span><span class=p>.</span><span class=n>table</span> <span class=o>=</span> <span class=n>zcalloc</span><span class=p>(</span><span class=n>realsize</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=n>dictEntry</span><span class=o>*</span><span class=p>));</span>
    <span class=n>n</span><span class=p>.</span><span class=n>used</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=cm>/* Is this the first initialization? If so it&#39;s not really a rehashing
</span><span class=cm>     * we just set the first hash table so that it can accept keys. */</span>
  	<span class=c1>// 第一次初始化也会通过这里来完成创建
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>table</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>DICT_OK</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* Prepare a second hash table for incremental rehashing */</span>
  	<span class=c1>// ht[1] 开始派上用场,扩容时是在 ht[1] 上操作, rehash 完毕后,在交换到 ht[0]
</span><span class=c1></span>    <span class=n>d</span><span class=o>-&gt;</span><span class=n>ht</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
    <span class=n>d</span><span class=o>-&gt;</span><span class=n>rehashidx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>DICT_OK</span><span class=p>;</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>从 <code>dictExpand</code> 这个函数可以发现做了这么几件事:</p><ol><li>校验是否可以执行 <code>rehash</code></li><li>创建一个新的哈希表 <code>n</code>, 分配更大的内存</li><li>将哈希表 <code>n</code> 复制给 <code>ht[1]</code>, 将 <code>rehashidx</code> 标志置为 0 ,意味着开启了渐进式rehash. 该值也标志渐进式rehash当前已经进行到了哪个hash槽.</li></ol><p>该函数没有将key重新 <code>rehash</code> 到新的 <code>slot</code> 上,而是交由增删改查的操作, 以及后台定时任务来处理.</p><a class=post-dummy-target id=增删改查辅助rehash></a><h5>增删改查辅助rehash</h5><p>看源码其实可以发现在所有增删改查的源码中,开头都会有一个判断,是否处于渐进式rehash中.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>dictEntry</span> <span class=o>*</span><span class=nf>dictAddRaw</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>d</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>,</span> <span class=n>dictEntry</span> <span class=o>**</span><span class=n>existing</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>long</span> <span class=n>index</span><span class=p>;</span>
    <span class=n>dictEntry</span> <span class=o>*</span><span class=n>entry</span><span class=p>;</span>
    <span class=n>dictht</span> <span class=o>*</span><span class=n>ht</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>dictIsRehashing</span><span class=p>(</span><span class=n>d</span><span class=p>))</span> <span class=n>_dictRehashStep</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
		<span class=p>...</span>
<span class=p>}</span>
<span class=c1>// 进入 rehash 后是 &gt;=0的值
</span><span class=c1></span><span class=cp>#define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)
</span><span class=cp></span><span class=cm>/*
</span><span class=cm> * 此函数仅执行一步hash表的重散列，并且仅当没有安全迭代器绑定到哈希表时。
</span><span class=cm> * 当我们在重新散列中有迭代器时，我们不能混淆打乱两个散列表的数据，否则某些元素可能被遗漏或重复遍历。
</span><span class=cm> *
</span><span class=cm> * 该函数被在字典中查找或更新等普通操作调用，以致字典中的数据能自动的从哈系表１迁移到哈系表２
</span><span class=cm> */</span>
<span class=k>static</span> <span class=kt>void</span> <span class=nf>_dictRehashStep</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>d</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=o>-&gt;</span><span class=n>iterators</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=n>dictRehash</span><span class=p>(</span><span class=n>d</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=后台任务rehash></a><h5>后台任务rehash</h5><p>虽然redis实现了在读写操作时,辅助服务器进行渐进式rehash操作,但是如果服务器比较空闲,redis数据库将很长时间内都一直使用两个哈希表.所以在redis周期函数中,如果发现有字典正在进行渐进式rehash操作,则会花费<strong>1毫秒</strong>的时间,帮助一起进行渐进式rehash操作.</p><p>还是上面缩容时使用的任务函数<code>databasesCron</code>.源码如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* Rehash */</span>
<span class=k>if</span> <span class=p>(</span><span class=n>server</span><span class=p>.</span><span class=n>activerehashing</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>dbs_per_call</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>work_done</span> <span class=o>=</span> <span class=n>incrementallyRehash</span><span class=p>(</span><span class=n>rehash_db</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>work_done</span><span class=p>)</span> <span class=p>{</span>
      <span class=cm>/* If the function did some work, stop here, we&#39;ll do
</span><span class=cm>                 * more at the next cron loop. */</span>
      <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=cm>/* If this db didn&#39;t need rehash, we&#39;ll try the next one. */</span>
      <span class=n>rehash_db</span><span class=o>++</span><span class=p>;</span>
      <span class=n>rehash_db</span> <span class=o>%=</span> <span class=n>server</span><span class=p>.</span><span class=n>dbnum</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=渐进式rehash弊端></a><h4>渐进式rehash弊端</h4><p>渐进式rehash避免了redis阻塞,可以说非常完美,但是由于在rehash时,需要分配一个新的hash表,在rehash期间,同时有两个hash表在使用,会使得redis内存使用量瞬间突增,在Redis 满容状态下由于Rehash会导致大量Key驱逐.</p><a class=post-dummy-target id=zset-有序集合></a><h2>Zset 有序集合</h2><p>首先 <code>zset</code> 是一个 <code>set</code> 结构,拥有 <code>set</code> 的所有特性,其次他可以给每一个 <code>value</code> 赋予一个 <code>score</code> 作为权重.内部实现用的跳表(<code>skiplist</code>)</p><a class=post-dummy-target id=常用命令-4></a><h3>常用命令</h3><p><a href=https://redis.io/commands/zadd>ZADD</a>,<a href=https://redis.io/commands/zrange>ZRANGE</a>,<a href=https://redis.io/commands/zrevrange>ZREVRANGE</a>,<a href=https://redis.io/commands/zscore>ZSCORE</a>,<a href=https://redis.io/commands/zcard>ZCARD</a>,<a href=https://redis.io/commands/zrank>ZRANK</a>&hellip;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=o>&gt;</span> <span class=n>zadd</span> <span class=n>books</span> <span class=mf>9.0</span> <span class=s>&#34;think in java&#34;</span>
<span class=p>(</span><span class=n>integer</span><span class=p>)</span> <span class=mi>1</span>
<span class=o>&gt;</span> <span class=n>zadd</span> <span class=n>books</span> <span class=mf>8.9</span> <span class=s>&#34;java concurrency&#34;</span>
<span class=p>(</span><span class=n>integer</span><span class=p>)</span> <span class=mi>1</span>
<span class=o>&gt;</span> <span class=n>zadd</span> <span class=n>books</span> <span class=mf>8.6</span> <span class=s>&#34;java cookbook&#34;</span>
<span class=p>(</span><span class=n>integer</span><span class=p>)</span> <span class=mi>1</span>
<span class=o>&gt;</span> <span class=n>zrange</span> <span class=n>books</span> <span class=mi>0</span> <span class=o>-</span><span class=mi>1</span>  <span class=err>#</span> <span class=err>按</span> <span class=n>score</span> <span class=err>排序列出，参数区间为排名范围</span>
<span class=mi>1</span><span class=p>)</span> <span class=s>&#34;java cookbook&#34;</span>
<span class=mi>2</span><span class=p>)</span> <span class=s>&#34;java concurrency&#34;</span>
<span class=mi>3</span><span class=p>)</span> <span class=s>&#34;think in java&#34;</span>
<span class=o>&gt;</span> <span class=n>zrevrange</span> <span class=n>books</span> <span class=mi>0</span> <span class=o>-</span><span class=mi>1</span>  <span class=err>#</span> <span class=err>按</span> <span class=n>score</span> <span class=err>逆序列出，参数区间为排名范围</span>
<span class=mi>1</span><span class=p>)</span> <span class=s>&#34;think in java&#34;</span>
<span class=mi>2</span><span class=p>)</span> <span class=s>&#34;java concurrency&#34;</span>
<span class=mi>3</span><span class=p>)</span> <span class=s>&#34;java cookbook&#34;</span>
<span class=o>&gt;</span> <span class=n>zcard</span> <span class=n>books</span>  <span class=err>#</span> <span class=err>相当于</span> <span class=n>count</span><span class=p>()</span>
<span class=p>(</span><span class=n>integer</span><span class=p>)</span> <span class=mi>3</span>
<span class=o>&gt;</span> <span class=n>zscore</span> <span class=n>books</span> <span class=s>&#34;java concurrency&#34;</span>  <span class=err>#</span> <span class=err>获取指定</span> <span class=n>value</span> <span class=err>的</span> <span class=n>score</span>
<span class=s>&#34;8.9000000000000004&#34;</span>  <span class=err>#</span> <span class=err>内部</span> <span class=n>score</span> <span class=err>使用</span> <span class=kt>double</span> <span class=err>类型进行存储，所以存在小数点精度问题</span>
<span class=o>&gt;</span> <span class=n>zrank</span> <span class=n>books</span> <span class=s>&#34;java concurrency&#34;</span>  <span class=err>#</span> <span class=err>排名</span>
<span class=p>(</span><span class=n>integer</span><span class=p>)</span> <span class=mi>1</span>
<span class=o>&gt;</span> <span class=n>zrangebyscore</span> <span class=n>books</span> <span class=mi>0</span> <span class=mf>8.91</span>  <span class=err>#</span> <span class=err>根据分值区间遍历</span> <span class=n>zset</span>
<span class=mi>1</span><span class=p>)</span> <span class=s>&#34;java cookbook&#34;</span>
<span class=mi>2</span><span class=p>)</span> <span class=s>&#34;java concurrency&#34;</span>
<span class=o>&gt;</span> <span class=n>zrangebyscore</span> <span class=n>books</span> <span class=o>-</span><span class=n>inf</span> <span class=mf>8.91</span> <span class=n>withscores</span> <span class=err>#</span> <span class=err>根据分值区间</span> <span class=p>(</span><span class=o>-</span><span class=err>∞</span><span class=p>,</span> <span class=mf>8.91</span><span class=p>]</span> <span class=err>遍历</span> <span class=n>zset</span><span class=err>，同时返回分值。</span><span class=n>inf</span> <span class=err>代表</span> <span class=n>infinite</span><span class=err>，无穷大的意思。</span>
<span class=mi>1</span><span class=p>)</span> <span class=s>&#34;java cookbook&#34;</span>
<span class=mi>2</span><span class=p>)</span> <span class=s>&#34;8.5999999999999996&#34;</span>
<span class=mi>3</span><span class=p>)</span> <span class=s>&#34;java concurrency&#34;</span>
<span class=mi>4</span><span class=p>)</span> <span class=s>&#34;8.9000000000000004&#34;</span>
<span class=o>&gt;</span> <span class=n>zrem</span> <span class=n>books</span> <span class=s>&#34;java concurrency&#34;</span>  <span class=err>#</span> <span class=err>删除</span> <span class=n>value</span>
<span class=p>(</span><span class=n>integer</span><span class=p>)</span> <span class=mi>1</span>
<span class=o>&gt;</span> <span class=n>zrange</span> <span class=n>books</span> <span class=mi>0</span> <span class=o>-</span><span class=mi>1</span>
<span class=mi>1</span><span class=p>)</span> <span class=s>&#34;java cookbook&#34;</span>
<span class=mi>2</span><span class=p>)</span> <span class=s>&#34;think in java&#34;</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=数据结构></a><h3>数据结构</h3><p>众所周知, <code>Zset</code> 是一个有序的set集合, <code>redis</code> 通过 <code>hash table</code> 来存储 value 和 score 的映射关系,可以达到 <code>O(1)</code>, 通过 score 排序或者说按照 score 范围来获取这个区间的 value, 则是通过 <strong>跳表</strong> 来实现的. <code>Zset</code> 可以达到 <code>O(log(N))</code> 的插入和读写.</p><a class=post-dummy-target id=什么是跳跃列表></a><h4>什么是跳跃列表?</h4><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191102201627.png alt=skiplist class=lazyload><figcaption class=image-caption>skiplist</figcaption></figure></p><p>如图,跳跃列表是指具有纵向高度的有序链表.跳表会随机的某提升些链表的高度,并将每一层的节点进行连接,相当于构建<code>多级索引</code>,这样在查找的时候,从最高层开始查,可以过滤掉一大部分的范围,有点类似于二分查找.跳表也是典型的<code>空间换时间</code>的方式.</p><p>每一个 kv 块对应的结构如下面的代码中的<code>zslnode</code>结构,kv header 也是这个结构,只不过 value 字段是 null 值——无效的,score 是 <code>Double.MIN_VALUE</code>,用来垫底的。</p><a class=post-dummy-target id=struct-1></a><h4>struct</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>zslnode</span> <span class=p>{</span>
  <span class=n>string</span> <span class=n>value</span><span class=p>;</span>
  <span class=kt>double</span> <span class=n>score</span><span class=p>;</span>
  <span class=n>zslnode</span><span class=o>*</span><span class=p>[]</span> <span class=n>forwards</span><span class=p>;</span>  <span class=c1>// 多层连接指针
</span><span class=c1></span>  <span class=n>zslnode</span><span class=o>*</span> <span class=n>backward</span><span class=p>;</span>  <span class=c1>// 回溯指针
</span><span class=c1></span><span class=p>}</span>

<span class=k>struct</span> <span class=n>zsl</span> <span class=p>{</span>
  <span class=n>zslnode</span><span class=o>*</span> <span class=n>header</span><span class=p>;</span> <span class=c1>// 跳跃列表头指针
</span><span class=c1></span>  <span class=kt>int</span> <span class=n>maxLevel</span><span class=p>;</span> <span class=c1>// 跳跃列表当前的最高层
</span><span class=c1></span>  <span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=n>zslnode</span><span class=o>*&gt;</span> <span class=n>ht</span><span class=p>;</span> <span class=c1>// hash 结构的所有键值对
</span><span class=c1></span><span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=redis中跳表的优化></a><h4>redis中跳表的优化</h4><ol><li>允许 score 是重复的</li><li>比较不仅是通过 key(即 score), 也还会比较 data</li><li>最底层(<code>Level 1</code>)是有反向指针的,所以是一个双向链表,这样适用于从大到小的排序需求(<code>ZREVRANGE</code>)</li></ol><a class=post-dummy-target id=一次查找的过程></a><h4>一次查找的过程</h4><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191102202313.png alt=lookup-order class=lazyload><figcaption class=image-caption>lookup-order</figcaption></figure></p><a class=post-dummy-target id=redis中level是如何生成的></a><h4>redis中level是如何生成的?</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* Returns a random level for the new skiplist node we are going to create.
</span><span class=cm> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
</span><span class=cm> * (both inclusive), with a powerlaw-alike distribution where higher
</span><span class=cm> * levels are less likely to be returned. */</span>
<span class=kt>int</span> <span class=nf>zslRandomLevel</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>level</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>((</span><span class=n>random</span><span class=p>()</span><span class=o>&amp;</span><span class=mh>0xFFFF</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>ZSKIPLIST_P</span> <span class=o>*</span> <span class=mh>0xFFFF</span><span class=p>))</span>
        <span class=n>level</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>level</span><span class=o>&lt;</span><span class=n>ZSKIPLIST_MAXLEVEL</span><span class=p>)</span> <span class=o>?</span> <span class=nl>level</span> <span class=p>:</span> <span class=n>ZSKIPLIST_MAXLEVEL</span><span class=p>;</span> 
<span class=p>}</span></code></pre></td></tr></table></div></div><p><code>ZSKIPLIST_MAXLEVEL</code> 最大值是 <code>64</code>, 也就是最多 64 层.<code>ZSKIPLIST_P</code> 为 <code>1/4</code>, 也就是说有 25% 的概率有机会获得level,要获得更高的level,概率更小. 这也就导致了, redis中的跳表层级不会特别高,较扁平,较低层节点较多.有个小优化的地方: 跳表会记录下当前的最高层数 <code>MaxLevel</code> 这样就不需要从最顶层开始遍历了.</p><a class=post-dummy-target id=为什么使用跳表而不是红黑树或者哈希表></a><h4>为什么使用跳表而不是红黑树或者哈希表?</h4><ul><li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li><li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li><li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li><li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li></ul><a class=post-dummy-target id=参考></a><h2>参考</h2><ol><li><a href=https://luoming1224.github.io/2018/11/12/[redis学习笔记]redis渐进式rehash机制/>渐进式 rehash 机制</a></li><li><a href=https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html>美团针对Redis Rehash机制的探索和实践</a></li><li><a href=https://zsr.github.io/2017/07/03/redis-zset内部实现/>zset内部实现</a></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 2019-10-24 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://xiaohei.im/2019/10/24/posts/data-structure/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://xiaohei.im/tags/redis/><i class="fas fa-tag fa-fw"></i>redis</a></span>
<span class=tag><a href=https://xiaohei.im/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><i class="fas fa-tag fa-fw"></i>数据结构</a></span></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://xiaohei.im/>主页</a></span></section></div><div class=post-nav><a href=https://xiaohei.im/2019/10/23/posts/rabbitmq-ack-confirm/ class=prev rel=prev title=RabbitMQ-消息确认机制><i class="fas fa-angle-left fa-fw"></i>RabbitMQ-消息确认机制</a>
<a href=https://xiaohei.im/2019/11/03/posts/distributed-lock/ class=next rel=next title=Redis-分布式锁>Redis-分布式锁<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"2019-10-24 09:59:11 \x2b0800 \x2b0800",title:"Redis-数据结构",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xiaohei.im/>xiaoheiAh</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>