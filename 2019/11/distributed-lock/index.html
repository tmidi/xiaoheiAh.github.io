<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Redis-分布式锁 | xiaohei&#39;s blog | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content=赵小黑的各种记录><link rel=prev href=https://xiaohei.im/2019/10/data-structure/><link rel=next href=https://xiaohei.im/2019/11/obj/><link rel=canonical href=https://xiaohei.im/2019/11/distributed-lock/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content=Redis-分布式锁><meta name=twitter:description content="分布式锁有很多中实现(纯数据库,zookeeper,redis),纯数据库的受限于数据库性能,zk 可以保证加锁的顺序,是公平锁.Redis中的实现就是接下来要学习的."><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Redis-分布式锁","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xiaohei.im\/2019\/11\/distributed-lock\/"},"image":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/cover.png","width":800,"height":600},"genre":"posts","keywords":"分布式锁, redis","wordcount":1996,"url":"https:\/\/xiaohei.im\/2019\/11\/distributed-lock\/","datePublished":"2019-11-03T14:49:56\x2b08:00","dateModified":"2019-11-03T14:49:56\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class=navbar-header><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX">Redis-分布式锁</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://xiaohei.im/ rel=author><i class="fas fa-user-circle fa-fw"></i>xiaoheiAh&nbsp;</a>
<span class=post-category>收录于
<i class="far fa-folder fa-fw"></i><a href=https://xiaohei.im/categories/redis/>redis</a></span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-11-03>2019-11-03</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 1996 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 4 分钟&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#为什么使用分布式锁>为什么使用分布式锁?</a><ul><li><a href=#分布式锁的特点>分布式锁的特点?</a></li></ul></li><li><a href=#如何使用分布式锁>如何使用分布式锁?</a><ul><li><a href=#简单粗暴版>简单粗暴版</a></li><li><a href=#redission版>Redission版</a></li><li><a href=#redlock>RedLock</a><ul><li><a href=#加锁过程>加锁过程</a></li></ul></li></ul></li><li><a href=#分布式锁的一些问题>分布式锁的一些问题</a><ul><li><a href=#锁被其他客户端释放>锁被其他客户端释放</a><ul><li><a href=#如何解决>如何解决?</a></li></ul></li><li><a href=#超时问题>超时问题</a><ul><li><a href=#如何解决-1>如何解决?</a></li></ul></li><li><a href=#时钟不一致>时钟不一致</a><ul><li><a href=#如何解决-2>如何解决?</a></li></ul></li><li><a href=#性能-故障恢复和-fsync>性能、故障恢复和 fsync</a></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>目录</span><span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#为什么使用分布式锁>为什么使用分布式锁?</a><ul><li><a href=#分布式锁的特点>分布式锁的特点?</a></li></ul></li><li><a href=#如何使用分布式锁>如何使用分布式锁?</a><ul><li><a href=#简单粗暴版>简单粗暴版</a></li><li><a href=#redission版>Redission版</a></li><li><a href=#redlock>RedLock</a><ul><li><a href=#加锁过程>加锁过程</a></li></ul></li></ul></li><li><a href=#分布式锁的一些问题>分布式锁的一些问题</a><ul><li><a href=#锁被其他客户端释放>锁被其他客户端释放</a><ul><li><a href=#如何解决>如何解决?</a></li></ul></li><li><a href=#超时问题>超时问题</a><ul><li><a href=#如何解决-1>如何解决?</a></li></ul></li><li><a href=#时钟不一致>时钟不一致</a><ul><li><a href=#如何解决-2>如何解决?</a></li></ul></li><li><a href=#性能-故障恢复和-fsync>性能、故障恢复和 fsync</a></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>分布式锁有很多中实现(纯数据库,zookeeper,redis),纯数据库的受限于数据库性能,zk 可以保证加锁的顺序,是公平锁.Redis中的实现就是接下来要学习的.</p><a class=post-dummy-target id=为什么使用分布式锁></a><h2>为什么使用分布式锁?</h2><p>在分布式环境下想要保证只能有一个请求更新一条数据,普通的加锁(比如 Java 中的 <code>synchronized</code>,<code>JUC</code> 中的各种 <code>Lock</code>)都不能胜任. 分布式锁的意义在于可以将操作锁的权利中心化,从而串行控制业务的执行.但是使用分布式锁也有很多弊端,后面再说.</p><a class=post-dummy-target id=分布式锁的特点></a><h3>分布式锁的特点?</h3><ol><li><strong>互斥:</strong>具有强排他性,需要保证不同节点不同线程的互斥</li><li><strong>可重入:</strong>同一个节点的同一个线程如果获得了锁,那也可以再次获得</li><li><strong>高效,高可用:</strong>加锁解锁要高效,高可用保证分布式锁服务不会宕机失效</li><li><strong>阻塞/非阻塞:</strong>像 <code>ReentrantLock</code> 支持 <code>lock</code>, <code>tryLock</code>, <code>tryLock(long timeout)</code></li><li><strong>支持公平锁/非公平锁(Option)</strong></li></ol><a class=post-dummy-target id=如何使用分布式锁></a><h2>如何使用分布式锁?</h2><p>Redis中有多种实现分布式锁的方式,一个一个看看.</p><a class=post-dummy-target id=简单粗暴版></a><h3>简单粗暴版</h3><p>设置一个坑,让所有节点去抢就好.即语义为: <code>set if not exist</code>, 抢到后执行逻辑,逻辑完成后在<code>del</code>即可.</p><p><code>redis 2.8</code> 版本之前我们会通过以下方式:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><span class=lnt>1
</span></pre></td><td class=lntd><pre class=chroma>setnx {resource-name} {anystring}</pre></td></tr></table></div></div><p>我们还需要加一个过期时间,以免各种异常宕机情况导致锁无法释放的问题.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>expire key <span class=o>{</span>max-lock-time<span class=o>}</span></code></pre></td></tr></table></div></div><p>这两条命令并不是原子操作的,所以我们需要通过 <code>Lua</code> 脚本来保证其原子性</p><p><code>redis 2.8</code> 版本之后官方提供了 nx ex 的原子操作,使用起来更加简单了.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>set</span> <span class=o>{</span>resource-name<span class=o>}</span> <span class=o>{</span>anystring<span class=o>}</span> nx ex <span class=o>{</span>max-lock-time<span class=o>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=redission版></a><h3>Redission版</h3><blockquote><p><a href=https://github.com/redisson/redisson>https://github.com/redisson/redisson</a></p></blockquote><p><code>Redission</code> 和 <code>Jedis</code> 都是 Java 中的 redis 客户端, <code>Jedis</code> 使用的是阻塞式 I/O, 而 <code>Redission</code> 使用的 <code>Netty</code> 来进行通信,而且 API 封装更友好, 继承了 <code>java.util.concurrent.locks.Lock</code> 的接口,可以像操作本地 <code>Lock</code> 一样操作分布式锁. 而且 <code>Redission</code> 还提供了不同编程模式的 API: <code>sync/async</code>, <code>Reactive</code>, <code>RxJava</code>, 非常人性化. <code>Redission</code> 有丰富的接口实现以及对不同异常情况的处理设计很值得学习.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 1. 设置 config
</span><span class=c1></span><span class=n>Config</span> <span class=nf>config</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Config</span><span class=p>();</span>
<span class=c1>// 2. 创建 redission 实例
</span><span class=c1></span><span class=n>RedissonClient</span> <span class=nf>redisson</span> <span class=o>=</span> <span class=n>Redisson</span><span class=p>.</span><span class=na>create</span><span class=p>(</span><span class=n>config</span><span class=p>);</span>
<span class=c1>// 4. 获取锁
</span><span class=c1></span><span class=n>RLock</span> <span class=nf>lock</span> <span class=o>=</span> <span class=n>redisson</span><span class=p>.</span><span class=na>getLock</span><span class=p>(</span><span class=s>&#34;myLock&#34;</span><span class=p>);</span>
<span class=c1>// 5. 加锁
</span><span class=c1>// 方式一
</span><span class=c1>// 加锁以后10秒钟自动解锁
</span><span class=c1>// 无需调用unlock方法手动解锁
</span><span class=c1></span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>(</span><span class=n>10</span><span class=p>,</span> <span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span>
<span class=c1>// 方式二
</span><span class=c1>// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
</span><span class=c1></span><span class=kt>boolean</span> <span class=nf>res</span> <span class=o>=</span> <span class=n>lock</span><span class=p>.</span><span class=na>tryLock</span><span class=p>(</span><span class=n>100</span><span class=p>,</span> <span class=n>10</span><span class=p>,</span> <span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>res</span><span class=p>)</span> <span class=p>{</span>
   <span class=k>try</span> <span class=p>{</span>
     <span class=p>...</span>
   <span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
       <span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span>
   <span class=p>}</span>
<span class=p>}</span>
<span class=c1>// 方式三
</span><span class=c1>// 异步加锁
</span><span class=c1></span><span class=n>RLock</span> <span class=nf>lock</span> <span class=o>=</span> <span class=n>redisson</span><span class=p>.</span><span class=na>getLock</span><span class=p>(</span><span class=s>&#34;anyLock&#34;</span><span class=p>);</span>
<span class=n>lock</span><span class=p>.</span><span class=na>lockAsync</span><span class=p>();</span>
<span class=n>lock</span><span class=p>.</span><span class=na>lockAsync</span><span class=p>(</span><span class=n>10</span><span class=p>,</span> <span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span>
<span class=n>Future</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=nf>res</span> <span class=o>=</span> <span class=n>lock</span><span class=p>.</span><span class=na>tryLockAsync</span><span class=p>(</span><span class=n>100</span><span class=p>,</span> <span class=n>10</span><span class=p>,</span> <span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=redlock></a><h3>RedLock</h3><blockquote><p><a href=https://redis.io/topics/distlock>https://redis.io/topics/distlock</a></p></blockquote><p>上述的分布式锁实现都是基于单实例实现,所以会出现单点问题.胆大<code>RedLock</code> 基本原理是利用多个 <code>Redis</code> 集群，用多数的集群加锁成功，减少Redis某个集群出故障，造成分布式锁出现问题的概率。</p><a class=post-dummy-target id=加锁过程></a><h4>加锁过程</h4><ol><li>客户端获取当前的时间戳。</li><li>对 N 个 Redis 实例进行获取锁的操作，具体的操作同单机分布式锁。对 Redis 实例的操作时间需要远小于分布式锁的超时时间，这样可以保证在少数 Redis 节点 Down 掉的时候仍可快速对下一个节点进行操作。</li><li>客户端会记录所有实例返回加锁成功的时间，只有从多半的实例（在这里例子中 &gt;= 3）获取到了锁，且操作的时间远小于分布式锁的超时时间，锁才被人为是正确获取。</li><li>如果锁被成功获取了，当前分布式锁的合法时间为初始设定的合法时间减去上锁所花的时间。</li><li>若分布式锁获取失败，会强制对所有实例进行锁释放的操作，即使这个实例上不存在相应的键值。</li></ol><a class=post-dummy-target id=分布式锁的一些问题></a><h2>分布式锁的一些问题</h2><a class=post-dummy-target id=锁被其他客户端释放></a><h3>锁被其他客户端释放</h3><p>如果线程 A 在获取锁后处理业务时间过长,导致锁被自动释放了,此时 线程 B 重新获取到了锁. 线程 A 在执行完业务逻辑后释放锁(<code>DEL</code>操作),这是就会把线程 B 获取到的锁给释放掉.</p><a class=post-dummy-target id=如何解决></a><h4>如何解决?</h4><p>在设置 <code>value</code> 时,生成一个随机 token, 删除 key 时先做判断,只有在 token 与自己持有的相等时,才能删除. 由于需要保证原子性, 我们需要通过 <code>Lua</code> 脚本来实现.像下面这样,不过 <code>Redission</code> 已经有对应的实现了.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-lua data-lang=lua><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-lua data-lang=lua><span class=kr>if</span> <span class=n>redis.call</span><span class=p>(</span><span class=s2>&#34;get&#34;</span><span class=p>,</span><span class=n>KEYS</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=n>ARGV</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=kr>then</span>
    <span class=kr>return</span> <span class=n>redis.call</span><span class=p>(</span><span class=s2>&#34;del&#34;</span><span class=p>,</span><span class=n>KEYS</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
<span class=kr>else</span>
    <span class=kr>return</span> <span class=mi>0</span>
<span class=kr>end</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=超时问题></a><h3>超时问题</h3><p>如果在加锁和释放锁之间的业务逻辑过长,超出了锁的过期时间,那么就可能会导致另一个线程获取到锁,导致逻辑不能严格的串行执行.所以分布式锁的初衷是: 逻辑越短越好,持有锁的时间越短越好.</p><a class=post-dummy-target id=如何解决-1></a><h4>如何解决?</h4><p>这个目前没有太好解决的方案,后面如果看到了,就更新到这里.自己觉得: 尽量保证持锁时间短,优化代码逻辑.虽然可以延长锁的时间,但是会影响吞吐量的吧.如果真的有多个客户端持有了锁,还需要尽量保证业务逻辑中数据的幂等性,日志监控,及时报警,这样也可以做到尽快的人工介入.</p><blockquote><p>技术莫得银弹~适合的才是最好的.</p></blockquote><a class=post-dummy-target id=时钟不一致></a><h3>时钟不一致</h3><p><code>RedLock</code> 强依赖时间,所以机器时间不一致会有很大的问题</p><a class=post-dummy-target id=如何解决-2></a><h4>如何解决?</h4><ol><li>人为调整</li><li>NTP自动调整: 可以将时间精度控制在一定范围内.</li></ol><a class=post-dummy-target id=性能-故障恢复和-fsync></a><h3>性能、故障恢复和 fsync</h3><p>假设 Redis 没有持久性，当一个客户端获得了 5 个实例中的 3 个锁，若 3 个锁所在的实例 Down 掉了，实例再次启动时，其他的客户端也可以再次获得锁。</p><p>这个问题会因为开启了 Redis 的持久化而改观，对于 AOF 持久化（区别与 RDB 的二进制持久化，是文本持久化）。默认采用的是每秒钟通过 <code>fsync</code> 落盘，这意味着会丢失一秒内的数据，如果需要更有安全保证的持久化，可以设置 <code>fsync=always</code>，但对应的会损失一部分性能。</p><p>更好的解决办法是在实例 Down 掉后延迟一个略长于锁合法时间的时间，这样就可以保证在实例启动起来时锁一定是过期的，从而无须以损失性能为代价而使用 <code>fsync=always</code> 的持久化。</p><a class=post-dummy-target id=参考></a><h2>参考</h2><ol><li><a href=https://juejin.im/post/5bbb0d8df265da0abd3533a5>再有人问你分布式锁，这篇文章扔给他</a></li><li><a href=https://blog.brickgao.com/2018/05/06/distributed-lock-with-redlock/>RedLock中译</a></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 2019-11-03 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://xiaohei.im/2019/11/distributed-lock/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://xiaohei.im/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/><i class="fas fa-tag fa-fw"></i>分布式锁</a></span>
<span class=tag><a href=https://xiaohei.im/tags/redis/><i class="fas fa-tag fa-fw"></i>redis</a></span></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://xiaohei.im/>主页</a></span></section></div><div class=post-nav><a href=https://xiaohei.im/2019/10/data-structure/ class=prev rel=prev title=Redis-数据结构><i class="fas fa-angle-left fa-fw"></i>Redis-数据结构</a>
<a href=https://xiaohei.im/2019/11/obj/ class=next rel=next title=Redis-万物皆「对象」>Redis-万物皆「对象」<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"2019-11-03 14:49:56 \x2b0800 \x2b0800",title:"Redis-分布式锁",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xiaohei.im/>xiaoheiAh</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>