<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>[学习笔记] Netty | xiaohei&#39;s blog | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content=赵小黑的各种记录><link rel=prev href=https://xiaohei.im/2019/11/24/posts/cluster/><link rel=canonical href=https://xiaohei.im/2019/11/29/posts/netty/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content="[学习笔记] Netty"><meta name=twitter:description content><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[学习笔记] Netty","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xiaohei.im\/2019\/11\/29\/posts\/netty\/"},"image":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/cover.png","width":800,"height":600},"genre":"posts","keywords":"netty","wordcount":4881,"url":"https:\/\/xiaohei.im\/2019\/11\/29\/posts\/netty\/","datePublished":"2019-11-29T18:40:27\x2b08:00","dateModified":"2019-11-29T18:40:27\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX">[学习笔记] Netty</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://xiaohei.im/ rel=author><i class="fas fa-user-circle fa-fw"></i>xiaoheiAh&nbsp;</a>
<span class=post-category>收录于
<i class="far fa-folder fa-fw"></i><a href=https://xiaohei.im/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a></span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-11-29>2019-11-29</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 4881 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 10 分钟&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#netty-优点>netty 优点</a></li><li><a href=#server端>Server端</a><ul><li><a href=#handler-childhandler>handler() &amp; childHandler()</a></li><li><a href=#attr-childattr>attr() &amp; childAttr()</a></li><li><a href=#option-childoption>option() &amp; childOption()</a></li></ul></li><li><a href=#client端>Client端</a><ul><li><a href=#其他方法>其他方法</a></li></ul></li><li><a href=#bytebuf>ByteBuf</a><ul><li><a href=#bytebuf-容量相关api>ByteBuf 容量相关API</a><ul><li><a href=#capacity>capacity()</a></li><li><a href=#maxcapacity>maxCapacity()</a></li><li><a href=#readablebytes-与-isreadable>readableBytes() 与 isReadable()</a></li><li><a href=#writablebytes-iswritable-与-maxwritablebytes>writableBytes()、 isWritable() 与 maxWritableBytes()</a></li></ul></li><li><a href=#bytebuf-读写指针相关-api>ByteBuf 读写指针相关 API</a><ul><li><a href=#readerindex-与-readerindex-int>readerIndex() 与 readerIndex(int)</a></li><li><a href=#writeindex-与-writeindex-int>writeIndex() 与 writeIndex(int)</a></li><li><a href=#markreaderindex-与-resetreaderindex>markReaderIndex() 与 resetReaderIndex()</a></li><li><a href=#markwriterindex-与-resetwriterindex>markWriterIndex() 与 resetWriterIndex()</a></li></ul></li><li><a href=#bytebuf-读写-api>ByteBuf 读写 API</a><ul><li><a href=#writebytes-byte-src-与-buffer-readbytes-byte-dst>writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)</a></li><li><a href=#writebyte-byte-b-与-buffer-readbyte>writeByte(byte b) 与 buffer.readByte()</a></li><li><a href=#release-与-retain>release() 与 retain()</a></li><li><a href=#slice-duplicate-copy>slice()、duplicate()、copy()</a></li></ul></li></ul></li><li><a href=#pipeline-channelhandler>Pipeline &amp; ChannelHandler</a><ul><li><a href=#内置的-channelhandler>内置的 ChannelHandler</a></li></ul></li><li><a href=#粘包-拆包>粘包 &amp; 拆包</a><ul><li><a href=#tcp粘包-拆包发生的原因>TCP粘包/拆包发生的原因</a></li><li><a href=#解决策略>解决策略</a></li><li><a href=#netty-解决方案>netty 解决方案</a></li></ul></li><li><a href=#channelhandler-生命周期>ChannelHandler 生命周期</a></li><li><a href=#心跳-空闲检测>心跳 &amp; 空闲检测</a><ul><li><a href=#idlestatehandler>IdleStateHandler</a></li><li><a href=#实现一个心跳>实现一个心跳</a></li></ul></li><li><a href=#性能优化方案>性能优化方案</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>目录</span><span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><ul><li><a href=#netty-优点>netty 优点</a></li><li><a href=#server端>Server端</a><ul><li><a href=#handler-childhandler>handler() &amp; childHandler()</a></li><li><a href=#attr-childattr>attr() &amp; childAttr()</a></li><li><a href=#option-childoption>option() &amp; childOption()</a></li></ul></li><li><a href=#client端>Client端</a><ul><li><a href=#其他方法>其他方法</a></li></ul></li><li><a href=#bytebuf>ByteBuf</a><ul><li><a href=#bytebuf-容量相关api>ByteBuf 容量相关API</a><ul><li><a href=#capacity>capacity()</a></li><li><a href=#maxcapacity>maxCapacity()</a></li><li><a href=#readablebytes-与-isreadable>readableBytes() 与 isReadable()</a></li><li><a href=#writablebytes-iswritable-与-maxwritablebytes>writableBytes()、 isWritable() 与 maxWritableBytes()</a></li></ul></li><li><a href=#bytebuf-读写指针相关-api>ByteBuf 读写指针相关 API</a><ul><li><a href=#readerindex-与-readerindex-int>readerIndex() 与 readerIndex(int)</a></li><li><a href=#writeindex-与-writeindex-int>writeIndex() 与 writeIndex(int)</a></li><li><a href=#markreaderindex-与-resetreaderindex>markReaderIndex() 与 resetReaderIndex()</a></li><li><a href=#markwriterindex-与-resetwriterindex>markWriterIndex() 与 resetWriterIndex()</a></li></ul></li><li><a href=#bytebuf-读写-api>ByteBuf 读写 API</a><ul><li><a href=#writebytes-byte-src-与-buffer-readbytes-byte-dst>writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)</a></li><li><a href=#writebyte-byte-b-与-buffer-readbyte>writeByte(byte b) 与 buffer.readByte()</a></li><li><a href=#release-与-retain>release() 与 retain()</a></li><li><a href=#slice-duplicate-copy>slice()、duplicate()、copy()</a></li></ul></li></ul></li><li><a href=#pipeline-channelhandler>Pipeline &amp; ChannelHandler</a><ul><li><a href=#内置的-channelhandler>内置的 ChannelHandler</a></li></ul></li><li><a href=#粘包-拆包>粘包 &amp; 拆包</a><ul><li><a href=#tcp粘包-拆包发生的原因>TCP粘包/拆包发生的原因</a></li><li><a href=#解决策略>解决策略</a></li><li><a href=#netty-解决方案>netty 解决方案</a></li></ul></li><li><a href=#channelhandler-生命周期>ChannelHandler 生命周期</a></li><li><a href=#心跳-空闲检测>心跳 &amp; 空闲检测</a><ul><li><a href=#idlestatehandler>IdleStateHandler</a></li><li><a href=#实现一个心跳>实现一个心跳</a></li></ul></li><li><a href=#性能优化方案>性能优化方案</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。</p></blockquote><p><strong>NIO:</strong> selector 模型,用一个线程监听多个连接的读写请求,减少线程资源的浪费.</p><a class=post-dummy-target id=netty-优点></a><h3>netty 优点</h3><ol><li>使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞</li><li>Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型</li><li>Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</li><li>Netty 解决了 JDK 的很多包括空轮询在内的 Bug</li><li>Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理</li><li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li><li>Netty 社区活跃，遇到问题随时邮件列表或者 issue</li><li>Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li></ol><a class=post-dummy-target id=server端></a><h3>Server端</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 负责服务端的启动
</span><span class=c1></span><span class=n>ServerBootstrap</span> <span class=nf>serverBootstrap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ServerBootstrap</span><span class=p>();</span>
<span class=c1>// 负责接收新连接
</span><span class=c1></span><span class=n>NioEventLoopGroup</span> <span class=nf>boss</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NioEventLoopGroup</span><span class=p>();</span>
<span class=c1>// 负责读取数据及业务逻辑处理
</span><span class=c1></span><span class=n>NioEventLoopGroup</span> <span class=nf>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NioEventLoopGroup</span><span class=p>();</span>

<span class=n>serverBootstrap</span><span class=p>.</span><span class=na>group</span><span class=p>(</span><span class=n>boss</span><span class=p>,</span> <span class=n>worker</span><span class=p>)</span>
  <span class=c1>// 指定服务端 IO 模型为 NIO
</span><span class=c1></span>  <span class=p>.</span><span class=na>channel</span><span class=p>(</span><span class=n>NioServerSocketChannel</span><span class=p>.</span><span class=na>class</span><span class=p>)</span>
  <span class=c1>// 业务逻辑处理
</span><span class=c1></span>  <span class=p>.</span><span class=na>childHandler</span><span class=p>(</span><span class=k>new</span> <span class=n>ChannelInitializer</span><span class=o>&lt;</span><span class=n>NioSocketChannel</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>protected</span> <span class=nf>void</span> <span class=n>initChannel</span><span class=p>(</span><span class=n>NioSocketChannel</span> <span class=nf>ch</span><span class=p>)</span> <span class=kd>throws</span> <span class=nf>Exception</span> <span class=p>{</span>
      <span class=n>ch</span><span class=p>.</span><span class=na>pipeline</span><span class=p>().</span><span class=na>addLast</span><span class=p>(</span><span class=k>new</span> <span class=n>StringDecoder</span><span class=p>());</span>
      <span class=n>ch</span><span class=p>.</span><span class=na>pipeline</span><span class=p>().</span><span class=na>addLast</span><span class=p>(</span><span class=k>new</span> <span class=n>SimpleChannelInboundHandler</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
        <span class=kd>protected</span> <span class=nf>void</span> <span class=n>channelRead0</span><span class=p>(</span><span class=n>ChannelHandlerContext</span> <span class=nf>channelHandlerContext</span><span class=p>,</span> <span class=n>String</span> <span class=nf>s</span><span class=p>)</span> <span class=kd>throws</span> <span class=nf>Exception</span> <span class=p>{</span>
          <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
        <span class=p>}</span>
      <span class=p>});</span>
    <span class=p>}</span>
  <span class=p>})</span>
  <span class=p>.</span><span class=na>bind</span><span class=p>(</span><span class=n>8000</span><span class=p>);</span></code></pre></td></tr></table></div></div><ul><li><strong>NioSocketChannel/NioServerSocketChannel</strong> Netty 对 NIO 类型连接的抽象</li></ul><a class=post-dummy-target id=handler-childhandler></a><h4>handler() &amp; childHandler()</h4><ul><li>handler() 用于指定服务器端在启动过程中的一些逻辑</li><li>childHandler() 用于指定处理新连接数据的读写逻辑</li></ul><a class=post-dummy-target id=attr-childattr></a><h4>attr() &amp; childAttr()</h4><p>分别可以给服务端连接,客户端连接指定相应的属性,后续通过 <code>channel.attr()</code> 可以拿到.</p><a class=post-dummy-target id=option-childoption></a><h4>option() &amp; childOption()</h4><ul><li><p>option() 用于给服务端连接设定一系列的属性,最常见的是 <code>so_backlog</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数
</span><span class=c1></span><span class=n>serverBootstrap</span><span class=p>.</span><span class=na>option</span><span class=p>(</span><span class=n>ChannelOption</span><span class=p>.</span><span class=na>SO_BACKLOG</span><span class=p>,</span> <span class=n>1024</span><span class=p>)</span></code></pre></td></tr></table></div></div></li><li><p>childOption() 给每条连接设置一些属性</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=n>serverBootstrap</span>
			<span class=c1>// 是否开启TCP底层心跳机制，true为开启
</span><span class=c1></span>      <span class=p>.</span><span class=na>childOption</span><span class=p>(</span><span class=n>ChannelOption</span><span class=p>.</span><span class=na>SO_KEEPALIVE</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
			<span class=c1>// 是否开启Nagle算法，true表示关闭，false表示开启，通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。
</span><span class=c1></span>      <span class=p>.</span><span class=na>childOption</span><span class=p>(</span><span class=n>ChannelOption</span><span class=p>.</span><span class=na>TCP_NODELAY</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span></code></pre></td></tr></table></div></div></li></ul><a class=post-dummy-target id=client端></a><h3>Client端</h3><p>带连接失败重试的客户端,失败重试延迟为 2 的幂次.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 客户端启动
</span><span class=c1></span><span class=n>Bootstrap</span> <span class=nf>bootstrap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bootstrap</span><span class=p>();</span>
<span class=c1>// 线程模型
</span><span class=c1></span><span class=n>NioEventLoopGroup</span> <span class=nf>group</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NioEventLoopGroup</span><span class=p>();</span>

<span class=n>bootstrap</span><span class=p>.</span><span class=na>group</span><span class=p>(</span><span class=n>group</span><span class=p>)</span>
  <span class=c1>// 指定 IO 模型为 NIO
</span><span class=c1></span>  <span class=p>.</span><span class=na>channel</span><span class=p>(</span><span class=n>NioSocketChannel</span><span class=p>.</span><span class=na>class</span><span class=p>)</span>
  <span class=c1>// 业务逻辑处理
</span><span class=c1></span>  <span class=p>.</span><span class=na>handler</span><span class=p>(</span><span class=k>new</span> <span class=n>ChannelInitializer</span><span class=o>&lt;</span><span class=n>Channel</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>protected</span> <span class=nf>void</span> <span class=n>initChannel</span><span class=p>(</span><span class=n>Channel</span> <span class=nf>ch</span><span class=p>)</span> <span class=kd>throws</span> <span class=nf>Exception</span> <span class=p>{</span>
      <span class=n>ch</span><span class=p>.</span><span class=na>pipeline</span><span class=p>().</span><span class=na>addLast</span><span class=p>(</span><span class=k>new</span> <span class=n>StringEncoder</span><span class=p>());</span>
    <span class=p>}</span>
  <span class=p>});</span>
<span class=n>connect</span><span class=p>(</span><span class=n>bootstrap</span><span class=p>,</span><span class=s>&#34;127.0.0.1&#34;</span><span class=p>,</span> <span class=n>8000</span><span class=p>,</span> <span class=n>MAX_RETRY</span><span class=p>);</span>

<span class=kd>private</span> <span class=nf>static</span> <span class=kt>void</span> <span class=nf>connect</span><span class=p>(</span><span class=n>Bootstrap</span> <span class=nf>bootstrap</span><span class=p>,</span> <span class=n>String</span> <span class=nf>host</span><span class=p>,</span> <span class=kt>int</span> <span class=nf>port</span><span class=p>,</span> <span class=kt>int</span> <span class=nf>retry</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>bootstrap</span><span class=p>.</span><span class=na>connect</span><span class=p>(</span><span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>).</span><span class=na>addListener</span><span class=p>(</span><span class=n>future</span> <span class=o>-&gt;</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>future</span><span class=p>.</span><span class=na>isSuccess</span><span class=p>())</span> <span class=p>{</span>
            <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;连接成功!&#34;</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>retry</span> <span class=o>==</span> <span class=n>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>System</span><span class=p>.</span><span class=na>err</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;重试次数已用完，放弃连接！&#34;</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 第几次重连
</span><span class=c1></span>            <span class=kt>int</span> <span class=nf>order</span> <span class=o>=</span> <span class=p>(</span><span class=n>MAX_RETRY</span> <span class=o>-</span> <span class=n>retry</span><span class=p>)</span> <span class=o>+</span> <span class=n>1</span><span class=p>;</span>
            <span class=c1>// 本次重连的间隔
</span><span class=c1></span>            <span class=kt>int</span> <span class=nf>delay</span> <span class=o>=</span> <span class=n>1</span> <span class=o>&lt;&lt;</span> <span class=n>order</span><span class=p>;</span>
            <span class=n>System</span><span class=p>.</span><span class=na>err</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=k>new</span> <span class=n>Date</span><span class=p>()</span> <span class=o>+</span> <span class=s>&#34;: 连接失败，第&#34;</span> <span class=o>+</span> <span class=n>order</span> <span class=o>+</span> <span class=s>&#34;次重连……&#34;</span><span class=p>);</span>
            <span class=n>bootstrap</span><span class=p>.</span><span class=na>config</span><span class=p>().</span><span class=na>group</span><span class=p>().</span><span class=na>schedule</span><span class=p>(()</span> <span class=o>-&gt;</span> <span class=n>connect</span><span class=p>(</span><span class=n>bootstrap</span><span class=p>,</span> <span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>,</span> <span class=n>retry</span> <span class=o>-</span> <span class=n>1</span><span class=p>),</span> <span class=n>delay</span><span class=p>,</span> <span class=n>TimeUnit</span>
                    <span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>});</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=其他方法></a><h4>其他方法</h4><ul><li>attr() 客户端绑定属性</li><li>option() 设置客户端 TCP 连接</li></ul><a class=post-dummy-target id=bytebuf></a><h3>ByteBuf</h3><p>netty 中的数据都是以 <code>ByteBuf</code> 为单位的,所有需要写出的数据都必须塞到 <code>ByteBuf</code> 中.</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191202111539.png alt=ByteBuf-数据结构(掘金小册配图) class=lazyload><figcaption class=image-caption>ByteBuf-数据结构(掘金小册配图)</figcaption></figure></p><ol><li><code>ByteBuf</code> 是一个字节容器，容器里面的的数据分为三个部分，第一个部分是已经丢弃的字节，这部分数据是无效的；第二部分是可读字节，这部分数据是 <code>ByteBuf</code> 的主体数据， 从 <code>ByteBuf</code> 里面读取的数据都来自这一部分;最后一部分的数据是可写字节，所有写到 <code>ByteBuf</code> 的数据都会写到这一段。最后一部分虚线表示的是该 <code>ByteBuf</code> 最多还能扩容多少容量</li><li>以上三段内容是被两个指针给划分出来的，从左到右，依次是读指针（<code>readerIndex</code>）、写指针（<code>writerIndex</code>），然后还有一个变量 <code>capacity</code>，表示 <code>ByteBuf</code> 底层内存的总容量</li><li>从 ByteBuf 中每读取一个字节，<code>readerIndex</code> 自增1，<code>ByteBuf</code> 里面总共有 <code>writerIndex-readerIndex</code> 个字节可读, 由此可以推论出当 <code>readerIndex</code> 与 <code>writerIndex</code> 相等的时候，<code>ByteBuf</code> 不可读</li><li>写数据是从 <code>writerIndex</code> 指向的部分开始写，每写一个字节，<code>writerIndex</code> 自增1，直到增到 <code>capacity</code>，这个时候，表示 <code>ByteBuf</code> 已经不可写了</li><li><code>ByteBuf</code> 里面其实还有一个参数 <code>maxCapacity</code>，当向 <code>ByteBuf</code> 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 <code>capacity</code> 扩容到 <code>maxCapacity</code>，超过 <code>maxCapacity</code> 就会报错</li></ol><a class=post-dummy-target id=bytebuf-容量相关api></a><h4>ByteBuf 容量相关API</h4><a class=post-dummy-target id=capacity></a><h5>capacity()</h5><p>表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式，后面我们讲 ByteBuf 的分类的时候会讲到</p><a class=post-dummy-target id=maxcapacity></a><h5>maxCapacity()</h5><p>表示 ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常</p><a class=post-dummy-target id=readablebytes-与-isreadable></a><h5>readableBytes() 与 isReadable()</h5><p>readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</p><a class=post-dummy-target id=writablebytes-iswritable-与-maxwritablebytes></a><h5>writableBytes()、 isWritable() 与 maxWritableBytes()</h5><p>writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于 maxCapacity-writerIndex</p><a class=post-dummy-target id=bytebuf-读写指针相关-api></a><h4>ByteBuf 读写指针相关 API</h4><a class=post-dummy-target id=readerindex-与-readerindex-int></a><h5>readerIndex() 与 readerIndex(int)</h5><p>前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</p><a class=post-dummy-target id=writeindex-与-writeindex-int></a><h5>writeIndex() 与 writeIndex(int)</h5><p>前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</p><a class=post-dummy-target id=markreaderindex-与-resetreaderindex></a><h5>markReaderIndex() 与 resetReaderIndex()</h5><p>前者表示把当前的读指针保存起来，后者表示把当前的读指针恢复到之前保存的值</p><a class=post-dummy-target id=markwriterindex-与-resetwriterindex></a><h5>markWriterIndex() 与 resetWriterIndex()</h5><p>同上,但是针对写指针</p><a class=post-dummy-target id=bytebuf-读写-api></a><h4>ByteBuf 读写 API</h4><a class=post-dummy-target id=writebytes-byte-src-与-buffer-readbytes-byte-dst></a><h5>writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)</h5><p>writeBytes() 表示把字节数组 src 里面的数据全部写到 ByteBuf，而 readBytes() 指的是把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 readableBytes()，而 src 字节数组大小的长度通常小于等于 writableBytes()</p><a class=post-dummy-target id=writebyte-byte-b-与-buffer-readbyte></a><h5>writeByte(byte b) 与 buffer.readByte()</h5><p>writeByte() 表示往 ByteBuf 中写一个字节，而 buffer.readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() 与 readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble()</p><p>与读写 API 类似的 API 还有 getBytes、getByte() 与 setBytes()、setByte() 系列，唯一的区别就是 get/set 不会改变读写指针，而 read/write 会改变读写指针，这点在解析数据的时候千万要注意</p><a class=post-dummy-target id=release-与-retain></a><h5>release() 与 retain()</h5><p>由于 Netty 使用了 <strong>堆外内存</strong>，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们<strong>手动回收</strong>。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。</p><a class=post-dummy-target id=slice-duplicate-copy></a><h5>slice()、duplicate()、copy()</h5><p>这三个方法通常情况会放到一起比较，这三者的返回值都是一个新的 ByteBuf 对象</p><ol><li>slice() 方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 readableBytes()</li><li>duplicate() 方法把整个 ByteBuf 都截取出来，包括所有的数据，指针信息</li><li>slice() 方法与 duplicate() 方法的相同点是：<strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 slice() 或者 duplicate() 返回的 ByteBuf 调用 write 系列方法都会影响到 原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针</li><li>slice() 方法与 duplicate() 不同点就是：slice() 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整个 ByteBuf 都与原始的 ByteBuf 共享</li><li>slice() 方法与 duplicate() 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为，而最后一个方法 copy() 会直接从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，因此，<strong>往 copy() 返回的 ByteBuf 中写数据不会影响到原始的 ByteBuf</strong></li><li>slice() 和 duplicate() 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 release() 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 release() 方法，将引用计数降到零，才会释放内存</li><li>这三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响</li></ol><a class=post-dummy-target id=pipeline-channelhandler></a><h3>Pipeline &amp; ChannelHandler</h3><p><code>pipeline</code> 的数据结构为 双向链表, 节点的类型是一个 <code>ChannelHandlerContext</code> 包含着 每一个 <code>channel</code> 的上下文信息, <code>contenxt</code> 中包裹着一个 <code>handler</code> 用于处理用户的逻辑,<code>pipeline</code> 利用 <strong>责任链</strong> 的模式执行完所有的 <code>handler</code>.</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191202194426.png alt=掘金小册-pipeline构成 class=lazyload><figcaption class=image-caption>掘金小册-pipeline构成</figcaption></figure></p><a class=post-dummy-target id=内置的-channelhandler></a><h4>内置的 ChannelHandler</h4><ol><li><strong>ByteToMessageDecoder</strong></li></ol><p>二进制 -&gt; Java 对象转换,重写 <code>decode</code> 方法即可.默认情况下 <code>ByteBuf</code> 使用的是对外内存,通过引用计数判断是否需要清除.而该 <code>Decoder</code> 可以自动释放内存无需关心.</p><ol><li><strong>SimpleChannelInboundHandler</strong></li></ol><p>自动选择对应的消息进行处理,自动传递对象</p><ol><li><strong>MessageToByteEncoder</strong></li></ol><p>对象 -&gt; 二进制</p><a class=post-dummy-target id=粘包-拆包></a><h3>粘包 &amp; 拆包</h3><blockquote><p><a href=https://www.cnblogs.com/wade-luffy/p/6165671.html>https://www.cnblogs.com/wade-luffy/p/6165671.html</a></p></blockquote><p>TCP 的传输是基于字节流的,没有明显的分界,有可能会把应用层的多个包合在一块发出去(<strong>粘包</strong>),有可能把一个过大的包分多次发出(<strong>拆包</strong>),粘包/拆包是相对的,一方拆包,一方就要粘包.</p><a class=post-dummy-target id=tcp粘包-拆包发生的原因></a><h4>TCP粘包/拆包发生的原因</h4><p>问题产生的原因有三个，分别如下。</p><p>（1）应用程序write写入的字节大小大于套接口发送缓冲区大小；</p><p>（2）进行MSS大小的TCP分段；</p><p>（3）以太网帧的payload大于MTU进行IP分片。</p><a class=post-dummy-target id=解决策略></a><h4>解决策略</h4><p>通过应用层设计通用的结构保证.</p><ol><li>消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；</li><li>在包尾增加回车换行符进行分割，例如FTP协议；</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；</li><li>更复杂的应用层协议</li></ol><a class=post-dummy-target id=netty-解决方案></a><h4>netty 解决方案</h4><p>netty 提供了多种拆包器,满足用户的需求,不需要自己来对 <code>TCP</code> 流进行处理.</p><ol><li><p>固定长度拆包器 <strong>FixedLengthFrameDecoder</strong></p></li><li><p>行拆包器 <strong>LineBasedFrameDecoder</strong></p></li></ol><p>数据包以换行符作为分隔.</p><ol><li>分隔符拆包器 <strong>DelimiterBasedFrameDecoder</strong></li></ol><p>行拆包器的通用版,自定义分隔符</p><ol><li>基于长度域拆包器 <strong>LengthFieldBasedFrameDecoder</strong></li></ol><p>自定义的协议中包含长度域字段,即可使用来拆包</p><blockquote><p>每次的包不是定长的,怎么就能通过位移确认长度域,进而确定长度?</p><p>答: 通过设置一个完整包的开始标志,确定是一个新包就可以了.比如通常会设置一个魔数,拆包前先判断是不是我们定义的包.然后再去通过位移定位到长度域.</p></blockquote><a class=post-dummy-target id=channelhandler-生命周期></a><h3>ChannelHandler 生命周期</h3><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191203165854.png alt=生命周期图 class=lazyload><figcaption class=image-caption>生命周期图</figcaption></figure></p><ol><li><code>handlerAdded()</code> ：指的是当检测到新连接之后，调用 <code>ch.pipeline().addLast(new xxxHandler());</code> 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 处理器。</li><li><code>channelRegistered()</code>：这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，accept 到新的连接，然后创建一个线程来处理这条连接的读写，Netty 里面是使用了线程池的方式，只需要从线程池里面去抓一个线程绑定在这个 channel 上即可，这里的 NIO 线程通常指的是 <code>NioEventLoop</code>,不理解没关系，后面我们还会讲到。</li><li><code>channelActive()</code>：当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。</li><li><code>channelRead()</code>：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。</li><li><code>channelReadComplete()</code>：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。</li><li><code>channelInactive()</code>: 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 <strong>ESTABLISH</strong> 状态了</li><li><code>channelUnregistered()</code>: 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理</li><li><code>handlerRemoved()</code>：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。</li></ol><a class=post-dummy-target id=心跳-空闲检测></a><h3>心跳 &amp; 空闲检测</h3><a class=post-dummy-target id=idlestatehandler></a><h4>IdleStateHandler</h4><p>空闲检测(一段时间内是否有读写).</p><a class=post-dummy-target id=实现一个心跳></a><h4>实现一个心跳</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=nf>class</span> <span class=n>HeartBeatTimerHandler</span> <span class=nf>extends</span> <span class=n>ChannelInboundHandlerAdapter</span> <span class=p>{</span>

    <span class=kd>private</span> <span class=nf>static</span> <span class=kd>final</span> <span class=nf>int</span> <span class=n>HEARTBEAT_INTERVAL</span> <span class=o>=</span> <span class=n>5</span><span class=p>;</span>

    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=nf>void</span> <span class=n>channelActive</span><span class=p>(</span><span class=n>ChannelHandlerContext</span> <span class=nf>ctx</span><span class=p>)</span> <span class=kd>throws</span> <span class=nf>Exception</span> <span class=p>{</span>
        <span class=n>scheduleSendHeartBeat</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>

        <span class=kd>super</span><span class=p>.</span><span class=na>channelActive</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kd>private</span> <span class=nf>void</span> <span class=n>scheduleSendHeartBeat</span><span class=p>(</span><span class=n>ChannelHandlerContext</span> <span class=nf>ctx</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ctx</span><span class=p>.</span><span class=na>executor</span><span class=p>().</span><span class=na>schedule</span><span class=p>(()</span> <span class=o>-&gt;</span> <span class=p>{</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>isActive</span><span class=p>())</span> <span class=p>{</span>
                <span class=n>ctx</span><span class=p>.</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=k>new</span> <span class=n>HeartBeatRequestPacket</span><span class=p>());</span>
                <span class=n>scheduleSendHeartBeat</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
            <span class=p>}</span>

        <span class=p>},</span> <span class=n>HEARTBEAT_INTERVAL</span><span class=p>,</span> <span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=性能优化方案></a><h3>性能优化方案</h3><ol><li>共享 handler <code>@ChannelHandler.Sharable</code></li><li>压缩 handler - 合并编解码器 —— MessageToMessageCodec</li><li>虽然有状态的 handler 不能搞单例，但是你可以绑定到 channel 属性上，强行单例</li><li>缩短事件传播路径—— 放 Map 里，在第一个 handler 里根据指令来找具体 handler。</li><li>更改事件传播源—— 用 ctx.writeAndFlush() 不要用 ctx.channel().writeAndFlush()</li><li>减少阻塞主线程的操作—— 使用业务线程池，RPC 优化重点</li><li>计算耗时，使用回调 Future</li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 2019-11-29 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://xiaohei.im/2019/11/29/posts/netty/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://xiaohei.im/tags/netty/><i class="fas fa-tag fa-fw"></i>netty</a></span></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://xiaohei.im/>主页</a></span></section></div><div class=post-nav><a href=https://xiaohei.im/2019/11/24/posts/cluster/ class=prev rel=prev title="Redis HA - Cluster"><i class="fas fa-angle-left fa-fw"></i>Redis HA - Cluster</a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"2019-11-29 18:40:27 \x2b0800 \x2b0800",title:"[学习笔记] Netty",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xiaohei.im/>xiaoheiAh</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>