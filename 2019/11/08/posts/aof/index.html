<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Redis-AOF持久化 | xiaohei&#39;s blog | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content=赵小黑的各种记录><link rel=prev href=https://xiaohei.im/2019/11/06/posts/rdb/><link rel=next href=https://xiaohei.im/2019/11/14/posts/event/><link rel=canonical href=https://xiaohei.im/2019/11/08/posts/aof/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content=Redis-AOF持久化><meta name=twitter:description content="RDB 和 AOF 区别在于: 前者保存数据库快照,持久化所有键值对,后者通过保存 写命令 保证数据库的状态."><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Redis-AOF持久化","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xiaohei.im\/2019\/11\/08\/posts\/aof\/"},"image":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/cover.png","width":800,"height":600},"genre":"posts","keywords":"redis","wordcount":1481,"url":"https:\/\/xiaohei.im\/2019\/11\/08\/posts\/aof\/","datePublished":"2019-11-08T15:18:05\x2b08:00","dateModified":"2019-11-08T15:18:05\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX">Redis-AOF持久化</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://xiaohei.im/ rel=author><i class="fas fa-user-circle fa-fw"></i>xiaoheiAh&nbsp;</a>
<span class=post-category>收录于
<i class="far fa-folder fa-fw"></i><a href=https://xiaohei.im/categories/redis/>redis</a></span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-11-08>2019-11-08</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 1481 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 3 分钟&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#什么是-aof>什么是 AOF ?</a><ul><li><a href=#开启-aof>开启 AOF</a></li><li><a href=#aof-文件格式>AOF 文件格式</a></li><li><a href=#aof-持久化过程>AOF 持久化过程</a><ul><li><a href=#命令追加-append>命令追加 append</a></li><li><a href=#aof-写入同步>AOF 写入同步</a><ul><li><a href=#appendfsync>appendfsync</a></li></ul></li><li><a href=#aof-还原数据>AOF 还原数据</a></li></ul></li><li><a href=#aof-重写>AOF 重写</a><ul><li><a href=#触发条件>触发条件</a></li><li><a href=#重写过程>重写过程</a></li></ul></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>目录</span><span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#什么是-aof>什么是 AOF ?</a><ul><li><a href=#开启-aof>开启 AOF</a></li><li><a href=#aof-文件格式>AOF 文件格式</a></li><li><a href=#aof-持久化过程>AOF 持久化过程</a><ul><li><a href=#命令追加-append>命令追加 append</a></li><li><a href=#aof-写入同步>AOF 写入同步</a><ul><li><a href=#appendfsync>appendfsync</a></li></ul></li><li><a href=#aof-还原数据>AOF 还原数据</a></li></ul></li><li><a href=#aof-重写>AOF 重写</a><ul><li><a href=#触发条件>触发条件</a></li><li><a href=#重写过程>重写过程</a></li></ul></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><code>RDB</code> 和 <code>AOF</code> 区别在于: 前者保存数据库快照,持久化所有键值对,后者通过保存 <strong>写命令</strong> 保证数据库的状态.</p><a class=post-dummy-target id=什么是-aof></a><h2>什么是 AOF ?</h2><p><code>AOF</code> 持久化通过保存服务器执行的写命令实现,进行恢复时通过重放 <code>AOF</code> 文件中的写命令,来保证数据安全.就像 <code>mysql</code> 的 <code>binlog</code> 一样.</p><a class=post-dummy-target id=开启-aof></a><h3>开启 AOF</h3><p>通过在 <code>redis.conf</code> 中将 <code>appendonly</code> 设为 <code>yes</code> 即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># redis.conf</span>
appendonly yes
<span class=c1># 设置 aof 文件名字</span>
appendfilename <span class=s2>&#34;appendonly.aof&#34;</span>
<span class=c1># Redis支持三种不同的刷写模式：</span>
<span class=c1># appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。</span>
appendfsync everysec <span class=c1>#每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。</span>
<span class=c1># appendfsync no     #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=aof-文件格式></a><h3>AOF 文件格式</h3><p><code>AOF</code> 文件格式以 <code>redis</code> 命令请求协议为标准的,<code>*.aof</code> 文件可以直接打开.</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191112184639.png alt=redis设计与实现-aof格式 class=lazyload><figcaption class=image-caption>redis设计与实现-aof格式</figcaption></figure></p><a class=post-dummy-target id=aof-持久化过程></a><h3>AOF 持久化过程</h3><a class=post-dummy-target id=命令追加-append></a><h4>命令追加 append</h4><p><code>redis</code> 执行完客户端的写命令后,会将该命令以协议的格式写入到 <code>aof_buf</code> 中.该属性为 <code>redisServer</code> 中的一个.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#src/server.h
</span><span class=cp></span><span class=k>struct</span> <span class=n>redisServer</span> <span class=p>{</span>
 <span class=p>....</span>
 <span class=n>sds</span> <span class=n>aof_buf</span><span class=p>;</span>      <span class=cm>/* AOF buffer, written before entering the event loop */</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=aof-写入同步></a><h4>AOF 写入同步</h4><p><code>redis</code> 的服务进程是一个 <strong>事件循环</strong> - <code>event loop</code> , 每次循环大概会做三件事.</p><ol><li>文件事件: 接收客户端的命令,返回结果</li><li>时间事件: 执行系统的定时任务(<code>serverCron</code>), 完成渐进 <code>rehash</code> 扩容之类的操作</li><li><p>aof flush: 是否将 <code>aof_buf</code> 中的内容写入文件中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 伪代码</span>
def eventloop<span class=o>()</span>:
<span class=k>while</span> true:
	processFileEvents<span class=o>()</span> <span class=c1># 处理命令</span>
	processTimeEvents<span class=o>()</span> <span class=c1># 处理定时任务</span>
	flushAppendOnlyFile<span class=o>()</span> <span class=c1># 处理 aof 写入</span>
 	</code></pre></td></tr></table></div></div></li></ol><p><code>flushAppendOnlyFile</code> 中的动作是否执行是根据一个配置决定的.</p><a class=post-dummy-target id=appendfsync></a><h5>appendfsync</h5><p>该配置有几个值可选,默认是 <code>everysec</code>.</p><ol><li>always: 总是写入.只要程序执行到这一步了,就将 <code>aof_buf</code> 中命令协议写入到文件</li><li>everysec: 每秒写入. 每次执行前会先判断是否与上次写入间隔一秒,再次同步时通过 <strong>一个线程</strong> 专门执行</li><li>no: 不写入. 命令写入 <code>aof_buf</code> 后由操作系统决定何时同步到文件</li></ol><blockquote><p>fsync: 现代操作系统为了提高文件读写的效率,通常会将 <code>write</code> 函数写入的数据缓存在内存中,等到缓存空间填满或者超过一定时限,再将其写入磁盘.这样的问题在于宕机时缓存中的数据就无法恢复.所以操作系统提供了 <strong>fsync/fdatasync</strong> 两个函数,强制操作系统将数据立即写入磁盘,保证数据安全.两函数区别在于: 前者会更新文件的属性,后者只更新数据.</p></blockquote><p>三种模式在性能和数据上都有相对的优缺点. <code>always</code> 模式数据安全性更强,毕竟每次都是直接写入,但是就会影响性能.磁盘读写是比较慢的. <code>everysec</code> 模式性能较好,但会丢失一秒内的缓存数据. <code>no</code> 模式就完全取决于操作系统了.</p><a class=post-dummy-target id=aof-还原数据></a><h4>AOF 还原数据</h4><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://cdn.jsdelivr.net/gh/xiaoheiAh/imgs@master/20191113182005.png alt=redis设计与实现-aof还原数据 class=lazyload><figcaption class=image-caption>redis设计与实现-aof还原数据</figcaption></figure></p><a class=post-dummy-target id=aof-重写></a><h3>AOF 重写</h3><p><code>AOF</code> 重写的意思其实就是对单个命令的多个操作进行整理,留下最终态的执行命令来减少 <code>aof</code> 文件的大小.你可以想象一下执行 1w 次 <code>incr</code> 操作,写入 <code>aof</code> 1w 次的场景.</p><a class=post-dummy-target id=触发条件></a><h4>触发条件</h4><p><code>AOF</code> 重写可以自动触发.通过配置 <code>auto-aof-rewrite-min-size</code> 和<code>auto-aof-rewrite-percentage</code>,满足条件就会自动重写.具体可以查看官方的 <code>redis.conf</code></p><a class=post-dummy-target id=重写过程></a><h4>重写过程</h4><ol><li>创建子进程，根据内存里的数据重写<code>aof</code>，保存到<code>temp</code>文件</li><li>此时主进程还会接收命令，会将写操作追加到旧的<code>aof</code>文件中，并保存在<code>server.aof_rewrite_buf_blocks</code>中，通过管道发送给子进程存在<code>server.aof_child_diff</code>中，最后追加到<code>temp</code>文件结尾</li><li>子进程重写完成后退出，主进程根据子进程退出状态，判断成功与否。成功就将剩余的<code>server.aof_rewrite_buf_blocks</code>追加到<code>temp file</code>中，然后<code>rename()</code>覆盖原<code>aof</code>文件</li></ol><p>重写的过程中主进程还是会一直接受客户端的命令,所以重写子进程与主进程肯定会存在数据不一致的情况.<code>redis</code>针对这种情况作出了解决方案: 新增一个 <code>aof_rewrite_buf_blocks</code>, <code>aof</code> 写入命令时,不仅写入到 <code>aof_buf</code>, 如果正在重写,那么也写入到 <code>aof_rewrite_buf_blocks</code> 中,这样在子进程重写完毕后,可以将 <code>aof_rewrite_buf_blocks</code> 的命令追加到新文件中,保证数据不丢失.</p><p><code>rename</code> 操作是原子的,也是唯一会造成主进程阻塞的操作.</p><a class=post-dummy-target id=参考></a><h2>参考</h2><ol><li><a href=https://redis.io/topics/persistence>https://redis.io/topics/persistence</a></li><li><a href=https://youjiali1995.github.io/redis/persistence/>https://youjiali1995.github.io/redis/persistence/</a></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 2019-11-08 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://xiaohei.im/2019/11/08/posts/aof/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://xiaohei.im/tags/redis/><i class="fas fa-tag fa-fw"></i>redis</a></span></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://xiaohei.im/>主页</a></span></section></div><div class=post-nav><a href=https://xiaohei.im/2019/11/06/posts/rdb/ class=prev rel=prev title=Redis-RDB持久化><i class="fas fa-angle-left fa-fw"></i>Redis-RDB持久化</a>
<a href=https://xiaohei.im/2019/11/14/posts/event/ class=next rel=next title=Redis-事件>Redis-事件<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"2019-11-08 15:18:05 \x2b0800 \x2b0800",title:"Redis-AOF持久化",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xiaohei.im/>xiaoheiAh</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>