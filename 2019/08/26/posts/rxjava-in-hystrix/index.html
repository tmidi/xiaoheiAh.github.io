<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Hystrix命令执行流程 | xiaohei&#39;s blog | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content="Hystrix RxJava 响应式编程 响应式编程"><link rel=prev href=https://xiaohei.im/2019/08/21/posts/rxjava-guide/><link rel=next href=https://xiaohei.im/2019/09/03/posts/amqp-0-9-1-model-explained/><link rel=canonical href=https://xiaohei.im/2019/08/26/posts/rxjava-in-hystrix/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content=Hystrix命令执行流程><meta name=twitter:description content="Hystrix RxJava 响应式编程 响应式编程"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Hystrix命令执行流程","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xiaohei.im\/2019\/08\/26\/posts\/rxjava-in-hystrix\/"},"image":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/cover.png","width":800,"height":600},"genre":"posts","keywords":"rxjava, hystrix","wordcount":5629,"url":"https:\/\/xiaohei.im\/2019\/08\/26\/posts\/rxjava-in-hystrix\/","datePublished":"2019-08-26T15:25:08\x2b08:00","dateModified":"2019-08-26T15:25:08\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/logo.png","width":127,"height":40}},"description":"Hystrix RxJava 响应式编程 响应式编程"}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX">Hystrix命令执行流程</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://xiaohei.im/ rel=author><i class="fas fa-user-circle fa-fw"></i>xiaoheiAh&nbsp;</a>
<span class=post-category>收录于
<i class="far fa-folder fa-fw"></i><a href=https://xiaohei.im/categories/hystrix/>Hystrix</a></span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-08-26>2019-08-26</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 5629 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 12 分钟&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#hystrix简单介绍>Hystrix简单介绍</a></li><li><a href=#一次command执行>一次Command执行</a><ul><li><a href=#uml>UML</a></li><li><a href=#样例代码>样例代码</a></li><li><a href=#执行过程>执行过程</a><ul><li><a href=#流程图>流程图</a></li><li><a href=#hystrixcommand-java>HystrixCommand.java</a><ul><li><a href=#execute>execute</a></li><li><a href=#queue>queue</a></li></ul></li><li><a href=#blockingobservable-java>BlockingObservable.java</a></li><li><a href=#blockingoperatortofuture-java>BlockingOperatorToFuture.java</a></li><li><a href=#abstractcommand-java>AbstractCommand.java</a><ul><li><a href=#toobservable>toObservable</a></li><li><a href=#handlerequestcachehitandemitvalues>handleRequestCacheHitAndEmitValues</a></li><li><a href=#applyhystrixsemantics>applyHystrixSemantics</a></li><li><a href=#executecommandandobserve>executeCommandAndObserve</a></li><li><a href=#executecommandwithspecifiedisolation>executeCommandWithSpecifiedIsolation</a></li><li><a href=#getuserexecutionobservable>getUserExecutionObservable</a></li><li><a href=#getexecutionobservable>getExecutionObservable</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>目录</span><span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#hystrix简单介绍>Hystrix简单介绍</a></li><li><a href=#一次command执行>一次Command执行</a><ul><li><a href=#uml>UML</a></li><li><a href=#样例代码>样例代码</a></li><li><a href=#执行过程>执行过程</a><ul><li><a href=#流程图>流程图</a></li><li><a href=#hystrixcommand-java>HystrixCommand.java</a><ul><li><a href=#execute>execute</a></li><li><a href=#queue>queue</a></li></ul></li><li><a href=#blockingobservable-java>BlockingObservable.java</a></li><li><a href=#blockingoperatortofuture-java>BlockingOperatorToFuture.java</a></li><li><a href=#abstractcommand-java>AbstractCommand.java</a><ul><li><a href=#toobservable>toObservable</a></li><li><a href=#handlerequestcachehitandemitvalues>handleRequestCacheHitAndEmitValues</a></li><li><a href=#applyhystrixsemantics>applyHystrixSemantics</a></li><li><a href=#executecommandandobserve>executeCommandAndObserve</a></li><li><a href=#executecommandwithspecifiedisolation>executeCommandWithSpecifiedIsolation</a></li><li><a href=#getuserexecutionobservable>getUserExecutionObservable</a></li><li><a href=#getexecutionobservable>getExecutionObservable</a></li></ul></li></ul></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=前言></a><h2>前言</h2><p>Hystrix已经不在维护了,但是成功的开源项目总是值得学习的.刚开始看 Hystrix 源码时,会发现一堆 Action,Function 的逻辑,这其实就是 RxJava 的特点了&ndash;<strong>响应式编程</strong>.上篇文章已经对RxJava作过<a href=/2019/rxjava-guide/>入门介绍</a>,不熟悉的同学可以先去看看.本文会简单介绍 Hystrix,再根据demo结合源码来了解Hystrix的执行流程.</p><a class=post-dummy-target id=hystrix简单介绍></a><h2>Hystrix简单介绍</h2><ol><li><p>什么是 Hystrix?</p><p>Hystrix 是一个<strong>延迟</strong>和<strong>容错库</strong>，旨在隔离对远程系统、服务和第三方库的访问点，停止级联故障，并在错误不可避免的复杂分布式系统中能够弹性恢复。</p></li><li><p>核心概念</p><ol><li><p><strong>Command</strong> 命令</p><p><strong>Command</strong> 是Hystrix的入口,对用户来说,我们只需要创建对应的 command,将需要保护的接口包装起来就可以.可以无需关注再之后的逻辑.与 Spring 深度集成后还可以通过注解的方式,就更加对开发友好了.</p></li><li><p><strong>Circuit Breaker</strong> 断路器</p><p><strong>断路器</strong>,是从电气领域引申过来的概念,具有<strong>过载</strong>、<strong>短路</strong>和<strong>欠电压保护</strong>功能，有保护线路和电源的能力.在Hystrix中即为当请求超过一定比例响应失败时,hystrix 会对请求进行拦截处理,保证服务的稳定性,以及防止出现服务之间级联雪崩的可能性.</p></li><li><p><strong>Isolation</strong> 隔离策略</p><p>隔离策略是 Hystrix 的设计亮点所在,利用<a href=https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead>舱壁模式</a>的思想来对访问的资源进行隔离,每个资源是独立的依赖,单个资源的异常不应该影响到其他. Hystrix 的隔离策略目前有两种:<strong>线程池隔离</strong>,<strong>信号量隔离</strong>.</p></li></ol><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://github.com/Netflix/Hystrix/wiki/images/soa-5-isolation-focused-640.png alt=isolation class=lazyload><figcaption class=image-caption>isolation</figcaption></figure></p></li><li><p>Hystrix的运行流程</p></li></ol><blockquote><p>官方的 <a href=https://github.com/Netflix/Hystrix/wiki/How-it-Works>How it Works</a> 对流程有很详细的介绍,图示清晰,相信看完流程图就能对运行流程有一定的了解.</p></blockquote><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://raw.githubusercontent.com/wiki/Netflix/Hystrix/images/hystrix-command-flow-chart.png alt=来自hystrix的github站点 class=lazyload><figcaption class=image-caption>来自hystrix的github站点</figcaption></figure></p><a class=post-dummy-target id=一次command执行></a><h2>一次Command执行</h2><p><code>HystrixCommand</code>是标准的<a href=https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/command.html>命令模式</a>实现,每一次请求即为一次命令的创建执行经历的过程.从上述<a href=#Hystrix简单介绍>Hystrix流程图</a>可以看出创建流程最终会指向<code>toObservable</code>,在之前<a href=/2019/rxjava-guide/>RxJava入门</a>时有介绍到<code>Observable</code>即为被观察者,作用是发送数据给观察者进行相应的,因此可以知道这个方法应该是较为关键的.</p><a class=post-dummy-target id=uml></a><h3>UML</h3><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://i.loli.net/2019/08/29/gVF4dlR6tivBcT8.png alt=hystrixcommman-uml.png class=lazyload><figcaption class=image-caption>hystrixcommman-uml.png</figcaption></figure></p><ol><li>HystrixInvokable 标记这个一个可执行的接口,没有任何抽象方法或常量</li><li>HystrixExecutable 是为<code>HystrixCommand</code>设计的接口,主要提供执行命令的抽象方法,例如:<code>execute()</code>,<code>queue()</code>,<code>observe()</code></li><li>HystrixObservable 是为<code>Observable</code>设计的接口,主要提供自动订阅(<code>observe()</code>)和生成Observable(<code>toObservable()</code>)的抽象方法</li><li>HystrixInvokableInfo 提供大量的状态查询(获取属性配置,是否开启断路器等)</li><li>AbstractCommand <strong>核心逻辑</strong>的实现</li><li>HystrixCommand 定制逻辑实现以及留给用户实现的接口(比如:<code>run()</code>)</li></ol><a class=post-dummy-target id=样例代码></a><h3>样例代码</h3><p>通过新建一个 command 来看 Hystrix 是如何创建并执行的.HystrixCommand 是一个抽象类,其中有一个<code>run</code>方法需要我们实现自己的业务逻辑,以下是偷懒采用匿名内部类的形式呈现.构造方法的内部实现我们就不关注了,直接看下执行的逻辑吧.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=n>HystrixCommand</span> <span class=nf>demo</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HystrixCommand</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=p>(</span><span class=n>HystrixCommandGroupKey</span><span class=p>.</span><span class=na>Factory</span><span class=p>.</span><span class=na>asKey</span><span class=p>(</span><span class=s>&#34;demo-group&#34;</span><span class=p>))</span> <span class=p>{</span>
            <span class=nd>@Override</span>
            <span class=kd>protected</span> <span class=nf>String</span> <span class=n>run</span><span class=p>()</span> <span class=p>{</span>
                <span class=k>return</span> <span class=s>&#34;Hello World~&#34;</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>};</span>
<span class=n>demo</span><span class=p>.</span><span class=na>execute</span><span class=p>();</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=执行过程></a><h3>执行过程</h3><a class=post-dummy-target id=流程图></a><h4>流程图</h4><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://raw.githubusercontent.com/wiki/Netflix/Hystrix/images/hystrix-return-flow.png alt=execute class=lazyload><figcaption class=image-caption>execute</figcaption></figure></p><p>这是官方给出的一次完整调用的链路.上述的 demo 中我们直接调用了<code>execute</code>方法,所以调用的路径为<code>execute() -&gt; queue() -&gt; toObservable() -&gt; toBlocking() -&gt; toFuture() -&gt; get()</code>.核心的逻辑其实就在<code>toObservable()</code>中.</p><a class=post-dummy-target id=hystrixcommand-java></a><h4>HystrixCommand.java</h4><a class=post-dummy-target id=execute></a><h5>execute</h5><p><code>execute</code>方法为同步调用返回结果,并对异常作处理.内部会调用<code>queue</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 同步调用执行
</span><span class=c1></span><span class=kd>public</span> <span class=nf>R</span> <span class=n>execute</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>try</span> <span class=p>{</span>
    <span class=c1>// queue()返回的是Future类型的对象,所以这里是阻塞get
</span><span class=c1></span>    <span class=k>return</span> <span class=n>queue</span><span class=p>().</span><span class=na>get</span><span class=p>();</span>
  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=nf>e</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>throw</span> <span class=n>decomposeException</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=queue></a><h5>queue</h5><p><code>queue</code>的第一行代码完成了核心的订阅逻辑.</p><ol><li><code>toObservable()</code> 生成了 Hystrix 的 Observable 对象</li><li>将 <code>Observable</code> 转换为 <code>BlockingObservable</code> 可以阻塞控制数据发送</li><li><p><code>toFuture</code> 实现对 <code>BlockingObservable</code> 的订阅</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=nf>Future</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>queue</span><span class=p>()</span> <span class=p>{</span>
<span class=c1>// 着重关注的是这行代码
</span><span class=c1>// 完成了Observable的创建及订阅
</span><span class=c1>// toBlocking()是将Observable转为BlockingObservable,转换后的Observable可以阻塞数据的发送
</span><span class=c1></span><span class=kd>final</span> <span class=nf>Future</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>delegate</span> <span class=o>=</span> <span class=n>toObservable</span><span class=p>().</span><span class=na>toBlocking</span><span class=p>().</span><span class=na>toFuture</span><span class=p>();</span>

<span class=kd>final</span> <span class=nf>Future</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>f</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Future</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
<span class=c1>// 由于toObservable().toBlocking().toFuture()返回的Future如果中断了,
</span><span class=c1>// 不会对当前线程进行中断,所以这里将返回的Future进行了再次包装,处理异常逻辑
</span><span class=c1></span><span class=p>...</span>
<span class=p>}</span>

<span class=c1>// 判断是否已经结束了,有异常则直接抛出
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=na>isDone</span><span class=p>())</span> <span class=p>{</span>
<span class=k>try</span> <span class=p>{</span>
  <span class=n>f</span><span class=p>.</span><span class=na>get</span><span class=p>();</span>
  <span class=k>return</span> <span class=n>f</span><span class=p>;</span>
<span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=nf>e</span><span class=p>)</span> <span class=p>{</span>
			<span class=c1>// 省略这段判断
</span><span class=c1></span><span class=p>}</span>
<span class=p>}</span>

<span class=k>return</span> <span class=n>f</span><span class=p>;</span>
<span class=p>}</span></code></pre></td></tr></table></div></div></li></ol><a class=post-dummy-target id=blockingobservable-java></a><h4>BlockingObservable.java</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 被包装的Observable
</span><span class=c1></span><span class=kd>private</span> <span class=nf>final</span> <span class=n>Observable</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=nf>T</span><span class=o>&gt;</span> <span class=n>o</span><span class=p>;</span>

<span class=c1>// toBlocking()会调用该静态方法将 源Observable简单包装成BlockingObservable
</span><span class=c1></span><span class=kd>public</span> <span class=nf>static</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>BlockingObservable</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>from</span><span class=p>(</span><span class=kd>final</span> <span class=nf>Observable</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=nf>T</span><span class=o>&gt;</span> <span class=n>o</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=k>new</span> <span class=n>BlockingObservable</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>o</span><span class=p>);</span>
<span class=p>}</span>

<span class=kd>public</span> <span class=nf>Future</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>toFuture</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>BlockingOperatorToFuture</span><span class=p>.</span><span class=na>toFuture</span><span class=p>((</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=n>o</span><span class=p>);</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=blockingoperatortofuture-java></a><h4>BlockingOperatorToFuture.java</h4><blockquote><p><a href=http://reactivex.io/documentation/operators/to.html>ReactiveX 关于toFuture的解读</a></p><p>The <code>toFuture</code> operator applies to the <code>BlockingObservable</code> subclass, so in order to use it, you must first convert your source Observable into a <code>BlockingObservable</code> by means of either the <code>BlockingObservable.from</code> method or the <code>Observable.toBlocking</code> operator.</p></blockquote><p><code>toFuture</code>只能作用于<code>BlockingObservable</code>所以也才会有上文想要转换为BlockingObservable的操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 该操作将 源Observable转换为返回单个数据项的Future
</span><span class=c1></span><span class=kd>public</span> <span class=nf>static</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>Future</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>toFuture</span><span class=p>(</span><span class=n>Observable</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=nf>T</span><span class=o>&gt;</span> <span class=n>that</span><span class=p>)</span> <span class=p>{</span>
  	<span class=c1>// CountDownLatch 判断是否完成
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>CountDownLatch</span> <span class=n>finished</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CountDownLatch</span><span class=p>(</span><span class=n>1</span><span class=p>);</span>
  	<span class=c1>// 存储执行结果
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>AtomicReference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>value</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicReference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>();</span>
  	<span class=c1>// 存储错误结果
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>AtomicReference</span><span class=o>&lt;</span><span class=n>Throwable</span><span class=o>&gt;</span> <span class=nf>error</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicReference</span><span class=o>&lt;</span><span class=n>Throwable</span><span class=o>&gt;</span><span class=p>();</span>

  	<span class=c1>// single()方法可以限制Observable只发送单条数据
</span><span class=c1></span>  	<span class=c1>// 如果有多条数据 会抛 IllegalArgumentException
</span><span class=c1></span>  	<span class=c1>// 如果没有数据可以发送 会抛 NoSuchElementException
</span><span class=c1></span>    <span class=nd>@SuppressWarnings</span><span class=p>(</span><span class=s>&#34;unchecked&#34;</span><span class=p>)</span>
    <span class=kd>final</span> <span class=nf>Subscription</span> <span class=n>s</span> <span class=o>=</span> <span class=p>((</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=n>that</span><span class=p>).</span><span class=na>single</span><span class=p>().</span><span class=na>subscribe</span><span class=p>(</span><span class=k>new</span> <span class=n>Subscriber</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
				<span class=c1>// single()返回的Observable就可以对其进行标准的处理了
</span><span class=c1></span>        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>void</span> <span class=n>onCompleted</span><span class=p>()</span> <span class=p>{</span>
            <span class=n>finished</span><span class=p>.</span><span class=na>countDown</span><span class=p>();</span>
        <span class=p>}</span>

        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>void</span> <span class=n>onError</span><span class=p>(</span><span class=n>Throwable</span> <span class=nf>e</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>error</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span> <span class=n>e</span><span class=p>);</span>
            <span class=n>finished</span><span class=p>.</span><span class=na>countDown</span><span class=p>();</span>
        <span class=p>}</span>

        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>void</span> <span class=n>onNext</span><span class=p>(</span><span class=n>T</span> <span class=nf>v</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// &#34;single&#34; guarantees there is only one &#34;onNext&#34;
</span><span class=c1></span>            <span class=n>value</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>});</span>
		
  	<span class=c1>// 最后将Subscription返回的数据封装成Future,实现对应的逻辑
</span><span class=c1></span>    <span class=k>return</span> <span class=k>new</span> <span class=n>Future</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
			<span class=c1>// 可以查看源码
</span><span class=c1></span>    <span class=p>};</span>

<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=abstractcommand-java></a><h4>AbstractCommand.java</h4><p><code>AbstractCommand</code>是<code>toObservable</code>实现的地方,属于Hystrix的核心逻辑,代码较长,可以和方法调用的流程图一起食用.<code>toObservable</code>主要是完成缓存和创建Observable,requestLog的逻辑,当第一次创建Observable时,<code>applyHystrixSemantics</code>方法是Hystrix的语义实现,可以跳着看.</p><blockquote><p><strong>tips</strong>: 下文中有很多 Action和 Function,他们很相似,都有call方法,但是区别在于Function有返回值,而Action没有,方法后跟着的数字代表有几个入参.Func0/Func3即没有入参和有三个入参</p></blockquote><a class=post-dummy-target id=toobservable></a><h5>toObservable</h5><p><code>toObservable</code>代码较长且分层还是清晰的,所以下面一块一块写.其逻辑和文章开始提到的<a href=#Hystrix简单介绍>Hystrix流程图</a>是完全一致的.</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://i.loli.net/2019/09/02/CpGLzZtPXHuwsv8.png alt=toObservable.png class=lazyload><figcaption class=image-caption>toObservable.png</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>toObservable</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>final</span> <span class=nf>AbstractCommand</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>_cmd</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
  	<span class=c1>// 此处省略掉了很多个Action和Function,大部分是来做扫尾清理的函数,所以用到的时候再说
</span><span class=c1></span>  
  	<span class=c1>// defer在上篇rxjava入门中提到过,是一种创建型的操作符,每次订阅时会产生新的Observable,回调方法中所实现的才是真正我们需要的Observable
</span><span class=c1></span>    <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>defer</span><span class=p>(</span><span class=k>new</span> <span class=n>Func0</span><span class=o>&lt;</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span><span class=p>()</span> <span class=p>{</span>
        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>call</span><span class=p>()</span> <span class=p>{</span>
          	
						<span class=c1>// 校验命令的状态,保证其只执行一次
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>commandState</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>CommandState</span><span class=p>.</span><span class=na>NOT_STARTED</span><span class=p>,</span> <span class=n>CommandState</span><span class=p>.</span><span class=na>OBSERVABLE_CHAIN_CREATED</span><span class=p>))</span> <span class=p>{</span>
                <span class=n>IllegalStateException</span> <span class=nf>ex</span> <span class=o>=</span> <span class=k>new</span> <span class=n>IllegalStateException</span><span class=p>(</span><span class=s>&#34;This instance can only be executed once. Please instantiate a new instance.&#34;</span><span class=p>);</span>
                <span class=c1>//TODO make a new error type for this
</span><span class=c1></span>                <span class=k>throw</span> <span class=k>new</span> <span class=n>HystrixRuntimeException</span><span class=p>(</span><span class=n>FailureType</span><span class=p>.</span><span class=na>BAD_REQUEST_EXCEPTION</span><span class=p>,</span> <span class=n>_cmd</span><span class=p>.</span><span class=na>getClass</span><span class=p>(),</span> <span class=n>getLogMessagePrefix</span><span class=p>()</span> <span class=o>+</span> <span class=s>&#34; command executed multiple times - this is not permitted.&#34;</span><span class=p>,</span> <span class=n>ex</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span>
            <span class=p>}</span>

            <span class=n>commandStartTimestamp</span> <span class=o>=</span> <span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>();</span>
						<span class=c1>// properties为当前command的所有属性
</span><span class=c1></span>          	<span class=c1>// 允许记录请求log时会保存当前执行的command
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>properties</span><span class=p>.</span><span class=na>requestLogEnabled</span><span class=p>().</span><span class=na>get</span><span class=p>())</span> <span class=p>{</span>
                <span class=c1>// log this command execution regardless of what happened
</span><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>currentRequestLog</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>currentRequestLog</span><span class=p>.</span><span class=na>addExecutedCommand</span><span class=p>(</span><span class=n>_cmd</span><span class=p>);</span>
                <span class=p>}</span>
            <span class=p>}</span>
						
          	<span class=c1>// 是否开启了请求缓存
</span><span class=c1></span>            <span class=kd>final</span> <span class=nf>boolean</span> <span class=n>requestCacheEnabled</span> <span class=o>=</span> <span class=n>isRequestCachingEnabled</span><span class=p>();</span>
          	<span class=c1>// 获取缓存key
</span><span class=c1></span>            <span class=kd>final</span> <span class=nf>String</span> <span class=n>cacheKey</span> <span class=o>=</span> <span class=n>getCacheKey</span><span class=p>();</span>

            <span class=c1>// 开启缓存后,尝试从缓存中取
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>requestCacheEnabled</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>HystrixCommandResponseFromCache</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>fromCache</span> <span class=o>=</span> <span class=p>(</span><span class=n>HystrixCommandResponseFromCache</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>)</span> <span class=n>requestCache</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>cacheKey</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>fromCache</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>isResponseFromCache</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
                    <span class=k>return</span> <span class=n>handleRequestCacheHitAndEmitValues</span><span class=p>(</span><span class=n>fromCache</span><span class=p>,</span> <span class=n>_cmd</span><span class=p>);</span>
                <span class=p>}</span>
            <span class=p>}</span>
          	<span class=c1>// 没有开启请求缓存时,就执行正常的逻辑
</span><span class=c1></span>            <span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>hystrixObservable</span> <span class=o>=</span>
              			<span class=c1>// 这里又通过defer创建了我们需要的Observable
</span><span class=c1></span>                    <span class=n>Observable</span><span class=p>.</span><span class=na>defer</span><span class=p>(</span><span class=n>applyHystrixSemantics</span><span class=p>)</span>
              							<span class=c1>// 发送前会先走一遍hook,默认executionHook是空实现的,所以这里就跳过了
</span><span class=c1></span>                            <span class=p>.</span><span class=na>map</span><span class=p>(</span><span class=n>wrapWithAllOnNextHooks</span><span class=p>);</span>
          
            <span class=c1>// 得到最后的封装好的Observable后,将其放入缓存
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>requestCacheEnabled</span> <span class=o>&amp;&amp;</span> <span class=n>cacheKey</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                <span class=c1>// wrap it for caching
</span><span class=c1></span>                <span class=n>HystrixCachedObservable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>toCache</span> <span class=o>=</span> <span class=n>HystrixCachedObservable</span><span class=p>.</span><span class=na>from</span><span class=p>(</span><span class=n>hystrixObservable</span><span class=p>,</span> <span class=n>_cmd</span><span class=p>);</span>
                <span class=n>HystrixCommandResponseFromCache</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>fromCache</span> <span class=o>=</span> <span class=p>(</span><span class=n>HystrixCommandResponseFromCache</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>)</span> <span class=n>requestCache</span><span class=p>.</span><span class=na>putIfAbsent</span><span class=p>(</span><span class=n>cacheKey</span><span class=p>,</span> <span class=n>toCache</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>fromCache</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                    <span class=c1>// another thread beat us so we&#39;ll use the cached value instead
</span><span class=c1></span>                    <span class=n>toCache</span><span class=p>.</span><span class=na>unsubscribe</span><span class=p>();</span>
                    <span class=n>isResponseFromCache</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
                    <span class=k>return</span> <span class=n>handleRequestCacheHitAndEmitValues</span><span class=p>(</span><span class=n>fromCache</span><span class=p>,</span> <span class=n>_cmd</span><span class=p>);</span>
                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                    <span class=c1>// we just created an ObservableCommand so we cast and return it
</span><span class=c1></span>                    <span class=n>afterCache</span> <span class=o>=</span> <span class=n>toCache</span><span class=p>.</span><span class=na>toObservable</span><span class=p>();</span>
                <span class=p>}</span>
            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=n>afterCache</span> <span class=o>=</span> <span class=n>hystrixObservable</span><span class=p>;</span>
            <span class=p>}</span>

            <span class=k>return</span> <span class=n>afterCache</span>
              			<span class=c1>// 终止时的操作
</span><span class=c1></span>                    <span class=p>.</span><span class=na>doOnTerminate</span><span class=p>(</span><span class=n>terminateCommandCleanup</span><span class=p>)</span>     <span class=c1>// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))
</span><span class=c1></span>              			<span class=c1>// 取消订阅时的操作
</span><span class=c1></span>                    <span class=p>.</span><span class=na>doOnUnsubscribe</span><span class=p>(</span><span class=n>unsubscribeCommandCleanup</span><span class=p>)</span> <span class=c1>// perform cleanup once
</span><span class=c1></span>              			<span class=c1>// 完成时的操作
</span><span class=c1></span>                    <span class=p>.</span><span class=na>doOnCompleted</span><span class=p>(</span><span class=n>fireOnCompletedHook</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
                     </code></pre></td></tr></table></div></div><a class=post-dummy-target id=handlerequestcachehitandemitvalues></a><h5>handleRequestCacheHitAndEmitValues</h5><p>缓存击中时的处理</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>handleRequestCacheHitAndEmitValues</span><span class=p>(</span><span class=kd>final</span> <span class=nf>HystrixCommandResponseFromCache</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>fromCache</span><span class=p>,</span> <span class=kd>final</span> <span class=nf>AbstractCommand</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>_cmd</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>try</span> <span class=p>{</span>
          	<span class=c1>// Hystrix中有大量的hook 如果有心做二次开发的,可以利用这些hook做到很完善的监控
</span><span class=c1></span>            <span class=n>executionHook</span><span class=p>.</span><span class=na>onCacheHit</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>Throwable</span> <span class=nf>hookEx</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>logger</span><span class=p>.</span><span class=na>warn</span><span class=p>(</span><span class=s>&#34;Error calling HystrixCommandExecutionHook.onCacheHit&#34;</span><span class=p>,</span> <span class=n>hookEx</span><span class=p>);</span>
        <span class=p>}</span>   
  <span class=c1>// 将缓存的结果赋给当前command
</span><span class=c1></span>	<span class=k>return</span> <span class=n>fromCache</span><span class=p>.</span><span class=na>toObservableWithStateCopiedInto</span><span class=p>(</span><span class=k>this</span><span class=p>)</span>
    				<span class=c1>// doOnTerminate 或者是后面看到的doOnUnsubscribe,doOnError,都指的是在响应onTerminate/onUnsubscribe/onError后的操作,即在Observable的生命周期上注册一个动作优雅的处理逻辑
</span><span class=c1></span>            <span class=p>.</span><span class=na>doOnTerminate</span><span class=p>(</span><span class=k>new</span> <span class=n>Action0</span><span class=p>()</span> <span class=p>{</span>
                <span class=nd>@Override</span>
                <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>()</span> <span class=p>{</span>
                  	<span class=c1>// 命令最终状态的不同进行不同处理
</span><span class=c1></span>                    <span class=k>if</span> <span class=p>(</span><span class=n>commandState</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>CommandState</span><span class=p>.</span><span class=na>OBSERVABLE_CHAIN_CREATED</span><span class=p>,</span> <span class=n>CommandState</span><span class=p>.</span><span class=na>TERMINAL</span><span class=p>))</span> <span class=p>{</span>
                        <span class=n>cleanUpAfterResponseFromCache</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span> <span class=c1>//user code never ran
</span><span class=c1></span>                    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>commandState</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>CommandState</span><span class=p>.</span><span class=na>USER_CODE_EXECUTED</span><span class=p>,</span> <span class=n>CommandState</span><span class=p>.</span><span class=na>TERMINAL</span><span class=p>))</span> <span class=p>{</span>
                        <span class=n>cleanUpAfterResponseFromCache</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span> <span class=c1>//user code did run
</span><span class=c1></span>                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>})</span>
            <span class=p>.</span><span class=na>doOnUnsubscribe</span><span class=p>(</span><span class=k>new</span> <span class=n>Action0</span><span class=p>()</span> <span class=p>{</span>
                <span class=nd>@Override</span>
                <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>()</span> <span class=p>{</span>
	                  <span class=c1>// 命令最终状态的不同进行不同处理
</span><span class=c1></span>                    <span class=k>if</span> <span class=p>(</span><span class=n>commandState</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>CommandState</span><span class=p>.</span><span class=na>OBSERVABLE_CHAIN_CREATED</span><span class=p>,</span> <span class=n>CommandState</span><span class=p>.</span><span class=na>UNSUBSCRIBED</span><span class=p>))</span> <span class=p>{</span>
                        <span class=n>cleanUpAfterResponseFromCache</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span> <span class=c1>//user code never ran
</span><span class=c1></span>                    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>commandState</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>CommandState</span><span class=p>.</span><span class=na>USER_CODE_EXECUTED</span><span class=p>,</span> <span class=n>CommandState</span><span class=p>.</span><span class=na>UNSUBSCRIBED</span><span class=p>))</span> <span class=p>{</span>
                        <span class=n>cleanUpAfterResponseFromCache</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span> <span class=c1>//user code did run
</span><span class=c1></span>                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>});</span>
<span class=p>}</span>       </code></pre></td></tr></table></div></div><a class=post-dummy-target id=applyhystrixsemantics></a><h5>applyHystrixSemantics</h5><p>因为本片文章的主要目的是在讲执行流程,所以失败回退和断路器相关的就留到以后的文章中再写.</p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://i.loli.net/2019/09/02/M3djoYyUaVGFptB.png alt=applyHystrixSemantics.png class=lazyload><figcaption class=image-caption>applyHystrixSemantics.png</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=nf>Func0</span><span class=o>&lt;</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span> <span class=nf>applyHystrixSemantics</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Func0</span><span class=o>&lt;</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span><span class=p>()</span> <span class=p>{</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>call</span><span class=p>()</span> <span class=p>{</span>
      	<span class=c1>// 不再订阅了就返回不发送数据的Observable
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>commandState</span><span class=p>.</span><span class=na>get</span><span class=p>().</span><span class=na>equals</span><span class=p>(</span><span class=n>CommandState</span><span class=p>.</span><span class=na>UNSUBSCRIBED</span><span class=p>))</span> <span class=p>{</span>
          	<span class=c1>// 不发送任何数据或通知
</span><span class=c1></span>            <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>never</span><span class=p>();</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=n>applyHystrixSemantics</span><span class=p>(</span><span class=n>_cmd</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>};</span>

<span class=kd>private</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>applyHystrixSemantics</span><span class=p>(</span><span class=kd>final</span> <span class=nf>AbstractCommand</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>_cmd</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>// 标记开始执行的hook
</span><span class=c1></span>  <span class=c1>// 如果hook内抛异常了,会快速失败且没有fallback处理
</span><span class=c1></span>  <span class=n>executionHook</span><span class=p>.</span><span class=na>onStart</span><span class=p>(</span><span class=n>_cmd</span><span class=p>);</span>

  <span class=cm>/* determine if we&#39;re allowed to execute */</span>
  <span class=c1>// 断路器核心逻辑: 判断是否允许执行(TODO)
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>circuitBreaker</span><span class=p>.</span><span class=na>allowRequest</span><span class=p>())</span> <span class=p>{</span>
    <span class=c1>// Hystrix自己造的信号量轮子,之所以不用juc下,官方解释为juc的Semphore实现太复杂,而且没有动态调节的信号量大小的能力,简而言之,不满足需求!
</span><span class=c1></span>    <span class=c1>// 根据不同隔离策略(线程池隔离/信号量隔离)获取不同的TryableSemphore
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>TryableSemaphore</span> <span class=n>executionSemaphore</span> <span class=o>=</span> <span class=n>getExecutionSemaphore</span><span class=p>();</span>
    <span class=c1>// Semaphore释放标志
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>AtomicBoolean</span> <span class=n>semaphoreHasBeenReleased</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicBoolean</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span>
    
    <span class=c1>// 释放信号量的Action
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>Action0</span> <span class=n>singleSemaphoreRelease</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Action0</span><span class=p>()</span> <span class=p>{</span>
      <span class=nd>@Override</span>
      <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>semaphoreHasBeenReleased</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=kc>true</span><span class=p>))</span> <span class=p>{</span>
          <span class=n>executionSemaphore</span><span class=p>.</span><span class=na>release</span><span class=p>();</span>
        <span class=p>}</span>
      <span class=p>}</span>
    <span class=p>};</span>

    <span class=c1>// 异常处理
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>Action1</span><span class=o>&lt;</span><span class=n>Throwable</span><span class=o>&gt;</span> <span class=nf>markExceptionThrown</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Action1</span><span class=o>&lt;</span><span class=n>Throwable</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
      <span class=nd>@Override</span>
      <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>(</span><span class=n>Throwable</span> <span class=nf>t</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// HystrixEventNotifier是hystrix的插件,不同的事件发送不同的通知,默认是空实现.
</span><span class=c1></span>        <span class=n>eventNotifier</span><span class=p>.</span><span class=na>markEvent</span><span class=p>(</span><span class=n>HystrixEventType</span><span class=p>.</span><span class=na>EXCEPTION_THROWN</span><span class=p>,</span> <span class=n>commandKey</span><span class=p>);</span>
      <span class=p>}</span>
    <span class=p>};</span>
		
    <span class=c1>// 线程池隔离的TryableSemphore始终为true
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>executionSemaphore</span><span class=p>.</span><span class=na>tryAcquire</span><span class=p>())</span> <span class=p>{</span>
      <span class=k>try</span> <span class=p>{</span>
        <span class=cm>/* used to track userThreadExecutionTime */</span>
        <span class=c1>// executionResult是一次命令执行的结果信息封装
</span><span class=c1></span>        <span class=c1>// 这里设置起始时间是为了记录命令的生命周期,执行过程中会set其他属性进去
</span><span class=c1></span>        <span class=n>executionResult</span> <span class=o>=</span> <span class=n>executionResult</span><span class=p>.</span><span class=na>setInvocationStartTime</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>());</span>
        <span class=k>return</span> <span class=n>executeCommandAndObserve</span><span class=p>(</span><span class=n>_cmd</span><span class=p>)</span>
          <span class=c1>// 报错时的处理
</span><span class=c1></span>          <span class=p>.</span><span class=na>doOnError</span><span class=p>(</span><span class=n>markExceptionThrown</span><span class=p>)</span>
          <span class=c1>// 终止时释放
</span><span class=c1></span>          <span class=p>.</span><span class=na>doOnTerminate</span><span class=p>(</span><span class=n>singleSemaphoreRelease</span><span class=p>)</span>
          <span class=c1>// 取消订阅时释放
</span><span class=c1></span>          <span class=p>.</span><span class=na>doOnUnsubscribe</span><span class=p>(</span><span class=n>singleSemaphoreRelease</span><span class=p>);</span>
      <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>RuntimeException</span> <span class=nf>e</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>error</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
      <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=c1>// tryAcquire失败后会做fallback处理,TODO
</span><span class=c1></span>      <span class=k>return</span> <span class=n>handleSemaphoreRejectionViaFallback</span><span class=p>();</span>
    <span class=p>}</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=c1>// 断路器短路(拒绝请求)fallback处理 TODO
</span><span class=c1></span>    <span class=k>return</span> <span class=n>handleShortCircuitViaFallback</span><span class=p>();</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=executecommandandobserve></a><h5>executeCommandAndObserve</h5><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://i.loli.net/2019/09/02/qjDKmSk7QWUvO8X.png alt=executeCommandAndObserve.png class=lazyload><figcaption class=image-caption>executeCommandAndObserve.png</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * 执行run方法的地方
</span><span class=cm> */</span>
<span class=kd>private</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>executeCommandAndObserve</span><span class=p>(</span><span class=kd>final</span> <span class=nf>AbstractCommand</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>_cmd</span><span class=p>)</span> <span class=p>{</span>
  	<span class=c1>// 获取当前上下文
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>HystrixRequestContext</span> <span class=n>currentRequestContext</span> <span class=o>=</span> <span class=n>HystrixRequestContext</span><span class=p>.</span><span class=na>getContextForCurrentThread</span><span class=p>();</span>

  	<span class=c1>// 发送数据时的Action响应
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>Action1</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>markEmits</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Action1</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>(</span><span class=n>R</span> <span class=nf>r</span><span class=p>)</span> <span class=p>{</span>
          	<span class=c1>// 如果onNext时需要上报时,做以下处理
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>shouldOutputOnNextEvents</span><span class=p>())</span> <span class=p>{</span>
              	<span class=c1>// result标记
</span><span class=c1></span>                <span class=n>executionResult</span> <span class=o>=</span> <span class=n>executionResult</span><span class=p>.</span><span class=na>addEvent</span><span class=p>(</span><span class=n>HystrixEventType</span><span class=p>.</span><span class=na>EMIT</span><span class=p>);</span>
              	<span class=c1>// 通知
</span><span class=c1></span>                <span class=n>eventNotifier</span><span class=p>.</span><span class=na>markEvent</span><span class=p>(</span><span class=n>HystrixEventType</span><span class=p>.</span><span class=na>EMIT</span><span class=p>,</span> <span class=n>commandKey</span><span class=p>);</span>
            <span class=p>}</span>
          	<span class=c1>// commandIsScalar是一个我不解的地方,在网上也没有查到好的解释
</span><span class=c1></span>          	<span class=c1>// 该方法为抽象方法,有HystrixCommand实现返回true.HystrixObservableCommand返回false
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>commandIsScalar</span><span class=p>())</span> <span class=p>{</span>
              	<span class=c1>// 耗时
</span><span class=c1></span>                <span class=kt>long</span> <span class=nf>latency</span> <span class=o>=</span> <span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>()</span> <span class=o>-</span> <span class=n>executionResult</span><span class=p>.</span><span class=na>getStartTimestamp</span><span class=p>();</span>
              	<span class=c1>// 通知
</span><span class=c1></span>                <span class=n>eventNotifier</span><span class=p>.</span><span class=na>markCommandExecution</span><span class=p>(</span><span class=n>getCommandKey</span><span class=p>(),</span> <span class=n>properties</span><span class=p>.</span><span class=na>executionIsolationStrategy</span><span class=p>().</span><span class=na>get</span><span class=p>(),</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>latency</span><span class=p>,</span> <span class=n>executionResult</span><span class=p>.</span><span class=na>getOrderedList</span><span class=p>());</span>
                <span class=n>eventNotifier</span><span class=p>.</span><span class=na>markEvent</span><span class=p>(</span><span class=n>HystrixEventType</span><span class=p>.</span><span class=na>SUCCESS</span><span class=p>,</span> <span class=n>commandKey</span><span class=p>);</span>
                <span class=n>executionResult</span> <span class=o>=</span> <span class=n>executionResult</span><span class=p>.</span><span class=na>addEvent</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span> <span class=n>latency</span><span class=p>,</span> <span class=n>HystrixEventType</span><span class=p>.</span><span class=na>SUCCESS</span><span class=p>);</span>
              	<span class=c1>// 断路器标记成功(断路器半开时的反馈,决定是否关闭断路器)
</span><span class=c1></span>                <span class=n>circuitBreaker</span><span class=p>.</span><span class=na>markSuccess</span><span class=p>();</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>};</span>

    <span class=kd>final</span> <span class=nf>Action0</span> <span class=n>markOnCompleted</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Action0</span><span class=p>()</span> <span class=p>{</span>
        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>()</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>commandIsScalar</span><span class=p>())</span> <span class=p>{</span>
							<span class=c1>// 同markEmits 类似处理
</span><span class=c1></span>            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>};</span>

  	<span class=c1>// 失败回退的逻辑
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>Func1</span><span class=o>&lt;</span><span class=n>Throwable</span><span class=p>,</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span> <span class=nf>handleFallback</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Func1</span><span class=o>&lt;</span><span class=n>Throwable</span><span class=p>,</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span><span class=p>()</span> <span class=p>{</span>
        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>call</span><span class=p>(</span><span class=n>Throwable</span> <span class=nf>t</span><span class=p>)</span> <span class=p>{</span>
          <span class=c1>// 不是重点略过了
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>};</span>

  	<span class=c1>// 请求上下文的处理
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>Action1</span><span class=o>&lt;</span><span class=n>Notification</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=nf>R</span><span class=o>&gt;&gt;</span> <span class=n>setRequestContext</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Action1</span><span class=o>&lt;</span><span class=n>Notification</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=nf>R</span><span class=o>&gt;&gt;</span><span class=p>()</span> <span class=p>{</span>
        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>(</span><span class=n>Notification</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=nf>R</span><span class=o>&gt;</span> <span class=n>rNotification</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>setRequestContextIfNeeded</span><span class=p>(</span><span class=n>currentRequestContext</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>};</span>

    <span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>execution</span><span class=p>;</span>
  	<span class=c1>// 如果有执行超时限制,会将包装后的Observable再转变为支持TimeOut的
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>properties</span><span class=p>.</span><span class=na>executionTimeoutEnabled</span><span class=p>().</span><span class=na>get</span><span class=p>())</span> <span class=p>{</span>
      	<span class=c1>// 根据不同的隔离策略包装为不同的Observable
</span><span class=c1></span>        <span class=n>execution</span> <span class=o>=</span> <span class=n>executeCommandWithSpecifiedIsolation</span><span class=p>(</span><span class=n>_cmd</span><span class=p>)</span>
          			<span class=c1>// lift 是rxjava中一种基本操作符 可以将Observable转换成另一种Observable
</span><span class=c1></span>          			<span class=c1>// 包装为带有超时限制的Observable
</span><span class=c1></span>                <span class=p>.</span><span class=na>lift</span><span class=p>(</span><span class=k>new</span> <span class=n>HystrixObservableTimeoutOperator</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_cmd</span><span class=p>));</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>execution</span> <span class=o>=</span> <span class=n>executeCommandWithSpecifiedIsolation</span><span class=p>(</span><span class=n>_cmd</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>execution</span><span class=p>.</span><span class=na>doOnNext</span><span class=p>(</span><span class=n>markEmits</span><span class=p>)</span>
            <span class=p>.</span><span class=na>doOnCompleted</span><span class=p>(</span><span class=n>markOnCompleted</span><span class=p>)</span>
            <span class=p>.</span><span class=na>onErrorResumeNext</span><span class=p>(</span><span class=n>handleFallback</span><span class=p>)</span>
            <span class=p>.</span><span class=na>doOnEach</span><span class=p>(</span><span class=n>setRequestContext</span><span class=p>);</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=executecommandwithspecifiedisolation></a><h5>executeCommandWithSpecifiedIsolation</h5><p>根据不同的隔离策略创建不同的执行<code>Observable</code></p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://i.loli.net/2019/09/02/GCKHtruabSk3FDA.png alt=executeCommandSpecfi.png class=lazyload><figcaption class=image-caption>executeCommandSpecfi.png</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>executeCommandWithSpecifiedIsolation</span><span class=p>(</span><span class=kd>final</span> <span class=nf>AbstractCommand</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>_cmd</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>properties</span><span class=p>.</span><span class=na>executionIsolationStrategy</span><span class=p>().</span><span class=na>get</span><span class=p>()</span> <span class=o>==</span> <span class=n>ExecutionIsolationStrategy</span><span class=p>.</span><span class=na>THREAD</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)
</span><span class=c1></span>        <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>defer</span><span class=p>(</span><span class=k>new</span> <span class=n>Func0</span><span class=o>&lt;</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span><span class=p>()</span> <span class=p>{</span>
            <span class=nd>@Override</span>
            <span class=kd>public</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>call</span><span class=p>()</span> <span class=p>{</span>
              	<span class=c1>// 由于源码太长,这里只关注正常的流程,需要详细了解可以去看看源码
</span><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>threadState</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>ThreadState</span><span class=p>.</span><span class=na>NOT_USING_THREAD</span><span class=p>,</span> <span class=n>ThreadState</span><span class=p>.</span><span class=na>STARTED</span><span class=p>))</span> <span class=p>{</span>
                    <span class=k>try</span> <span class=p>{</span>
                        <span class=k>return</span> <span class=n>getUserExecutionObservable</span><span class=p>(</span><span class=n>_cmd</span><span class=p>);</span>
                    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>Throwable</span> <span class=nf>ex</span><span class=p>)</span> <span class=p>{</span>
                        <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>error</span><span class=p>(</span><span class=n>ex</span><span class=p>);</span>
                    <span class=p>}</span>
                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                    <span class=c1>//command has already been unsubscribed, so return immediately
</span><span class=c1></span>                    <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>error</span><span class=p>(</span><span class=k>new</span> <span class=n>RuntimeException</span><span class=p>(</span><span class=s>&#34;unsubscribed before executing run()&#34;</span><span class=p>));</span>
                <span class=p>}</span>
            <span class=p>}})</span>
        <span class=p>.</span><span class=na>doOnTerminate</span><span class=p>(</span><span class=k>new</span> <span class=n>Action0</span><span class=p>()</span> <span class=p>{})</span>
        <span class=p>.</span><span class=na>doOnUnsubscribe</span><span class=p>(</span><span class=k>new</span> <span class=n>Action0</span><span class=p>()</span> <span class=p>{})</span>
        <span class=c1>// 指定在某一个线程上执行,是rxjava中很重要的线程调度的概念
</span><span class=c1></span>        <span class=p>.</span><span class=na>subscribeOn</span><span class=p>(</span><span class=n>threadPool</span><span class=p>.</span><span class=na>getScheduler</span><span class=p>(</span><span class=k>new</span> <span class=n>Func0</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span><span class=p>()</span> <span class=p>{</span>
        <span class=p>}));</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// 信号量隔离策略
</span><span class=c1></span>        <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>defer</span><span class=p>(</span><span class=k>new</span> <span class=n>Func0</span><span class=o>&lt;</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span><span class=p>()</span> <span class=p>{</span>
						<span class=c1>// 逻辑与线程池大致相同
</span><span class=c1></span>        <span class=p>});</span>
    <span class=p>}</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=getuserexecutionobservable></a><h5>getUserExecutionObservable</h5><p>获取用户执行的逻辑</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>getUserExecutionObservable</span><span class=p>(</span><span class=kd>final</span> <span class=nf>AbstractCommand</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>_cmd</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>userObservable</span><span class=p>;</span>

    <span class=k>try</span> <span class=p>{</span>
      	<span class=c1>// getExecutionObservable是抽象方法,有HystrixCommand自行实现
</span><span class=c1></span>        <span class=n>userObservable</span> <span class=o>=</span> <span class=n>getExecutionObservable</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>Throwable</span> <span class=nf>ex</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// the run() method is a user provided implementation so can throw instead of using Observable.onError
</span><span class=c1></span>        <span class=c1>// so we catch it here and turn it into Observable.error
</span><span class=c1></span>        <span class=n>userObservable</span> <span class=o>=</span> <span class=n>Observable</span><span class=p>.</span><span class=na>error</span><span class=p>(</span><span class=n>ex</span><span class=p>);</span>
    <span class=p>}</span>
		<span class=c1>// 将Observable作其他中转
</span><span class=c1></span>    <span class=k>return</span> <span class=n>userObservable</span>
            <span class=p>.</span><span class=na>lift</span><span class=p>(</span><span class=k>new</span> <span class=n>ExecutionHookApplication</span><span class=p>(</span><span class=n>_cmd</span><span class=p>))</span>
            <span class=p>.</span><span class=na>lift</span><span class=p>(</span><span class=k>new</span> <span class=n>DeprecatedOnRunHookApplication</span><span class=p>(</span><span class=n>_cmd</span><span class=p>));</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p><strong>lift操作符</strong></p><p>lift可以转换成一个新的Observable,它很像一个代理,将原来的Observable代理到自己这里,订阅时通知原来的Observable发送数据,经自己这里流转加工处理再返回给订阅者.<code>Map/FlatMap</code>操作符底层其实就是用的<code>lift</code>进行实现的.</p><a class=post-dummy-target id=getexecutionobservable></a><h5>getExecutionObservable</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Override</span>
<span class=kd>final</span> <span class=nf>protected</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>getExecutionObservable</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>defer</span><span class=p>(</span><span class=k>new</span> <span class=n>Func0</span><span class=o>&lt;</span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;&gt;</span><span class=p>()</span> <span class=p>{</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=nf>Observable</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span> <span class=nf>call</span><span class=p>()</span> <span class=p>{</span>
      <span class=k>try</span> <span class=p>{</span>
        <span class=c1>// just操作符就是直接执行的Observable
</span><span class=c1></span>        <span class=c1>// run方法就是我们实现的业务逻辑: Hello World~
</span><span class=c1></span>        <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>just</span><span class=p>(</span><span class=n>run</span><span class=p>());</span>
      <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>Throwable</span> <span class=nf>ex</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>Observable</span><span class=p>.</span><span class=na>error</span><span class=p>(</span><span class=n>ex</span><span class=p>);</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}).</span><span class=na>doOnSubscribe</span><span class=p>(</span><span class=k>new</span> <span class=n>Action0</span><span class=p>()</span> <span class=p>{</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=nf>void</span> <span class=n>call</span><span class=p>()</span> <span class=p>{</span>
     	<span class=c1>// 执行订阅时将执行线程记为当前线程,必要时我们可以interrupt
</span><span class=c1></span>      <span class=n>executionThread</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>());</span>
    <span class=p>}</span>
  <span class=p>});</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=总结></a><h2>总结</h2><p>希望自己能把埋下的坑一一填完: 容错机制,metrics,断路器等等&hellip;</p><a class=post-dummy-target id=参考></a><h2>参考</h2><ol><li><a href=https://github.com/Netflix/Hystrix/wiki/How-it-Works>Hystrix How it Works</a></li><li><a href=http://reactivex.io/documentation/observable.html>ReactiveX官网</a></li><li><a href=https://github.com/ruanyf/document-style-guide>阮一峰: 中文技术文档写作规范</a></li><li><a href=https://blog.csdn.net/qq_24530405/article/details/66969886>RxJava lift 原理解析</a></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 2019-08-26 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://xiaohei.im/2019/08/26/posts/rxjava-in-hystrix/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://xiaohei.im/tags/rxjava/><i class="fas fa-tag fa-fw"></i>rxjava</a></span>
<span class=tag><a href=https://xiaohei.im/tags/hystrix/><i class="fas fa-tag fa-fw"></i>hystrix</a></span></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://xiaohei.im/>主页</a></span></section></div><div class=post-nav><a href=https://xiaohei.im/2019/08/21/posts/rxjava-guide/ class=prev rel=prev title=RxJava入门><i class="fas fa-angle-left fa-fw"></i>RxJava入门</a>
<a href=https://xiaohei.im/2019/09/03/posts/amqp-0-9-1-model-explained/ class=next rel=next title=AMQP消息模型>AMQP消息模型<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"2019-08-26 15:25:08 \x2b0800 \x2b0800",title:"Hystrix命令执行流程",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xiaohei.im/>xiaoheiAh</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>