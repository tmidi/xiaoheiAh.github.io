<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Collections-Hashmap | xiaohei&#39;s blog | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content=赵小黑的各种记录><link rel=prev href=https://xiaohei.im/2019/08/hashset/><link rel=next href=https://xiaohei.im/2019/08/arraylist/><link rel=canonical href=https://xiaohei.im/2019/08/hashmap/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content=Collections-Hashmap><meta name=twitter:description content><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Collections-Hashmap","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xiaohei.im\/2019\/08\/hashmap\/"},"image":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/cover.png","width":800,"height":600},"genre":"posts","keywords":"collections","wordcount":7079,"url":"https:\/\/xiaohei.im\/2019\/08\/hashmap\/","datePublished":"2019-08-15T13:19:18\x2b08:00","dateModified":"2019-08-15T13:19:18\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/xiaohei.im\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class=navbar-header><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a><a href=https://xiaohei.im/>xiaohei&#39;s blog | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xiaohei.im/posts/>文章</a>
<a class=menu-item href=https://xiaohei.im/tags/>标签</a>
<a class=menu-item href=https://xiaohei.im/categories/>分类</a>
<a class=menu-item href=https://xiaohei.im/about/>关于</a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX">Collections-Hashmap</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://xiaohei.im/ rel=author><i class="fas fa-user-circle fa-fw"></i>xiaoheiAh&nbsp;</a>
<span class=post-category>收录于
<i class="far fa-folder fa-fw"></i><a href=https://xiaohei.im/categories/corejava/>CoreJava</a></span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-08-15>2019-08-15</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 7079 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 15 分钟&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#hashmap-hashtable-concurrenthashmap的区别>HashMap,HashTable,ConcurrentHashMap的区别?</a></li><li><a href=#hashmap在不同版本之间实现的区别>HashMap在不同版本之间实现的区别?</a></li><li><a href=#官方文档介绍>官方文档介绍:</a></li><li><a href=#源码>源码</a></li><li><a href=#1-8红黑树化源码解析>1.8红黑树化源码解析</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>目录</span><span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#hashmap-hashtable-concurrenthashmap的区别>HashMap,HashTable,ConcurrentHashMap的区别?</a></li><li><a href=#hashmap在不同版本之间实现的区别>HashMap在不同版本之间实现的区别?</a></li><li><a href=#官方文档介绍>官方文档介绍:</a></li><li><a href=#源码>源码</a></li><li><a href=#1-8红黑树化源码解析>1.8红黑树化源码解析</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>美团的blog:<a href=https://tech.meituan.com/java_hashmap.html>https://tech.meituan.com/java_hashmap.html</a>
参考blog: <a href=https://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/>田小波的博客</a>
<a href=https://www.tianxiaobo.com/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/>红黑树介绍</a></p></blockquote><a class=post-dummy-target id=hashmap-hashtable-concurrenthashmap的区别></a><h2>HashMap,HashTable,ConcurrentHashMap的区别?</h2><p><strong>HashMap</strong>是非线程安全的,<strong>HashTable</strong>和<strong>ConcurrentHashMap</strong>是线程安全的.HashTable不允许null key和null Value,HashMap允许.
ConcurrentHashMap推出之后官方推荐不要在使用HashTable作为线程安全的使用类,而是使用这个.关于<strong>ConcurrentHashMap</strong>后面再学习.
&gt; <a href=https://juejin.im/post/5add97a46fb9a07aa212f4c0>参考blog</a></p><a class=post-dummy-target id=hashmap在不同版本之间实现的区别></a><h2>HashMap在不同版本之间实现的区别?</h2><blockquote><p><a href=http://linfenliang.com/hashmap/2017/08/04/HashMapInJDK-6-7-8-Differ/>区别</a></p></blockquote><a class=post-dummy-target id=官方文档介绍></a><h2>官方文档介绍:</h2><ol><li>基于<code>Map</code>接口实现的哈希表.提供了所有map可选的操作,允许key为null,value为null.<code>HashMap</code>与<code>HashTable</code>基本一致,除了<code>HashMap</code> <em>线程不安全并且允许为空</em>.
不保证有序,尤其不保证顺序一直不变(因为扩容时会rehash,基本上就顺序就重排了)</li><li>假设hash分布均匀的情况下,基本的操作(<code>get/put</code>)性能很不错.迭代所需要的时间与<code>buckets</code>数量与每个<code>bukets</code>下的键值对的数量之和成正比.所以官方建议如果要求hashmap的迭代性能的话,初始的<code>capacity</code>不能太高,<code>loadFactor</code>不要太高.</li><li><p>HashMap有两个重要的参数:<code>initial capacity</code>,<code>load factor</code>.capacity定义bucket的数量,initial capacity定义的是初始化bucket数量.load factor(中文名: <em>加载因子</em> )是判断哈希表是否需要扩容的阈值,当entries数量超过(load factor * current capacity),哈希表会触发<code>rehash</code>操作,内部数据结构会重整,buckets数量会变为之前大约两倍左右</p></li><li><p>通常情况下,load factor 默认<code>0.75f</code>,在时间空间上是很平衡的.值偏高时,空间减少,查找时间上升了(影响大部分的操作,get/put之类的),在设置初始容量时,需要考虑到预期的entries数量和加载因子,以便最小化rehash的数量.如果初始化的容量大于最大数量的entries除以加载因子,不会发生rehash操作.</p></li><li><p>如果有大量的键值对存到hashmap中,那么创建一个足够大的hashmap来存储要比让他自动rehash扩容来存储的性能要好很多.注意:具有相同hashcode的多个key肯定会影响哈希表的性能.为了改善这种影响,当key是Comparable类型时,可以通过key之间的比较顺序来打破这种关系.</p></li><li><p>注意hashmap是<code>Non synchronized</code>,即 <em>非线程安全</em>.如果多线程并发访问hashmap,并且至少有一个线程操作map的结构,在外部必须<code>synchronized</code>.(结构修改是指任何关于add或delte的操作,仅仅只是修改key关联的value时则不属于结构修改).通常在将object封装进map做synchronized操作</p></li><li><p>如果不存在上面的objects,那这个map需要被Collections.synchronizedMap包装下.最好在创建的时候就做好,防止偶然的并发访问.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=n>Map</span> <span class=nf>m</span> <span class=o>=</span> <span class=n>Collections</span><span class=p>.</span><span class=na>synchronizedMap</span><span class=p>(</span><span class=k>new</span> <span class=n>HashMap</span><span class=p>(...));</span></code></pre></td></tr></table></div></div></li><li><p>迭代器的所有方法都是<code>fail-fast</code>,如果迭代器创建后,在迭代器里的结构操作必须通过迭代器的方法来操作,否则会抛<code>ConcurrentModificationException</code>.因此,面对并发修改,迭代器会快速而干净的失败,而不是在未来的不确定时间冒任意非确定行为的风险.</p></li><li><p>请注意,迭代器的快速失败行为无法得到保证,因为一般来说,在存在不同步的并发修改时,不可能做出任何硬性保证. 快速失败迭代器会尽最大努力抛出ConcurrentModificationException. 因此,编写依赖于此异常的程序以确保其正确性是错误的:迭代器的快速失败行为应该仅用于检测错误.</p></li></ol><a class=post-dummy-target id=源码></a><h2>源码</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span><span class=lnt>317
</span><span class=lnt>318
</span><span class=lnt>319
</span><span class=lnt>320
</span><span class=lnt>321
</span><span class=lnt>322
</span><span class=lnt>323
</span><span class=lnt>324
</span><span class=lnt>325
</span><span class=lnt>326
</span><span class=lnt>327
</span><span class=lnt>328
</span><span class=lnt>329
</span><span class=lnt>330
</span><span class=lnt>331
</span><span class=lnt>332
</span><span class=lnt>333
</span><span class=lnt>334
</span><span class=lnt>335
</span><span class=lnt>336
</span><span class=lnt>337
</span><span class=lnt>338
</span><span class=lnt>339
</span><span class=lnt>340
</span><span class=lnt>341
</span><span class=lnt>342
</span><span class=lnt>343
</span><span class=lnt>344
</span><span class=lnt>345
</span><span class=lnt>346
</span><span class=lnt>347
</span><span class=lnt>348
</span><span class=lnt>349
</span><span class=lnt>350
</span><span class=lnt>351
</span><span class=lnt>352
</span><span class=lnt>353
</span><span class=lnt>354
</span><span class=lnt>355
</span><span class=lnt>356
</span><span class=lnt>357
</span><span class=lnt>358
</span><span class=lnt>359
</span><span class=lnt>360
</span><span class=lnt>361
</span><span class=lnt>362
</span><span class=lnt>363
</span><span class=lnt>364
</span><span class=lnt>365
</span><span class=lnt>366
</span><span class=lnt>367
</span><span class=lnt>368
</span><span class=lnt>369
</span><span class=lnt>370
</span><span class=lnt>371
</span><span class=lnt>372
</span><span class=lnt>373
</span><span class=lnt>374
</span><span class=lnt>375
</span><span class=lnt>376
</span><span class=lnt>377
</span><span class=lnt>378
</span><span class=lnt>379
</span><span class=lnt>380
</span><span class=lnt>381
</span><span class=lnt>382
</span><span class=lnt>383
</span><span class=lnt>384
</span><span class=lnt>385
</span><span class=lnt>386
</span><span class=lnt>387
</span><span class=lnt>388
</span><span class=lnt>389
</span><span class=lnt>390
</span><span class=lnt>391
</span><span class=lnt>392
</span><span class=lnt>393
</span><span class=lnt>394
</span><span class=lnt>395
</span><span class=lnt>396
</span><span class=lnt>397
</span><span class=lnt>398
</span><span class=lnt>399
</span><span class=lnt>400
</span><span class=lnt>401
</span><span class=lnt>402
</span><span class=lnt>403
</span><span class=lnt>404
</span><span class=lnt>405
</span><span class=lnt>406
</span><span class=lnt>407
</span><span class=lnt>408
</span><span class=lnt>409
</span><span class=lnt>410
</span><span class=lnt>411
</span><span class=lnt>412
</span><span class=lnt>413
</span><span class=lnt>414
</span><span class=lnt>415
</span><span class=lnt>416
</span><span class=lnt>417
</span><span class=lnt>418
</span><span class=lnt>419
</span><span class=lnt>420
</span><span class=lnt>421
</span><span class=lnt>422
</span><span class=lnt>423
</span><span class=lnt>424
</span><span class=lnt>425
</span><span class=lnt>426
</span><span class=lnt>427
</span><span class=lnt>428
</span><span class=lnt>429
</span><span class=lnt>430
</span><span class=lnt>431
</span><span class=lnt>432
</span><span class=lnt>433
</span><span class=lnt>434
</span><span class=lnt>435
</span><span class=lnt>436
</span><span class=lnt>437
</span><span class=lnt>438
</span><span class=lnt>439
</span><span class=lnt>440
</span><span class=lnt>441
</span><span class=lnt>442
</span><span class=lnt>443
</span><span class=lnt>444
</span><span class=lnt>445
</span><span class=lnt>446
</span><span class=lnt>447
</span><span class=lnt>448
</span><span class=lnt>449
</span><span class=lnt>450
</span><span class=lnt>451
</span><span class=lnt>452
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>    <span class=cm>/**
</span><span class=cm>     * The default initial capacity - MUST be a power of two.
</span><span class=cm>     * 默认的容量16 必须是2的n次方
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>DEFAULT_INITIAL_CAPACITY</span> <span class=o>=</span> <span class=n>1</span> <span class=o>&lt;&lt;</span> <span class=n>4</span><span class=p>;</span> <span class=c1>// aka 16
</span><span class=c1></span>
    <span class=cm>/**
</span><span class=cm>     * 最大的容量限制
</span><span class=cm>     * The maximum capacity, used if a higher value is implicitly specified
</span><span class=cm>     * by either of the constructors with arguments.
</span><span class=cm>     * MUST be a power of two &lt;= 1&lt;&lt;30.
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>MAXIMUM_CAPACITY</span> <span class=o>=</span> <span class=n>1</span> <span class=o>&lt;&lt;</span> <span class=n>30</span><span class=p>;</span>

    <span class=cm>/**
</span><span class=cm>     * 默认的加载因子
</span><span class=cm>     * The load factor used when none specified in constructor.
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>float</span> <span class=nf>DEFAULT_LOAD_FACTOR</span> <span class=o>=</span> <span class=n>0</span><span class=p>.</span><span class=na>75f</span><span class=p>;</span>
    <span class=cm>/**
</span><span class=cm>     * 大于这个值转红黑树
</span><span class=cm>     * The bin count threshold for using a tree rather than list for a
</span><span class=cm>     * bin.  Bins are converted to trees when adding an element to a
</span><span class=cm>     * bin with at least this many nodes. The value must be greater
</span><span class=cm>     * than 2 and should be at least 8 to mesh with assumptions in
</span><span class=cm>     * tree removal about conversion back to plain bins upon
</span><span class=cm>     * shrinkage.
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>TREEIFY_THRESHOLD</span> <span class=o>=</span> <span class=n>8</span><span class=p>;</span>

    <span class=cm>/**
</span><span class=cm>     * 大于这个值小于 TREEIFY_THRESHOLD 不转树
</span><span class=cm>     * The bin count threshold for untreeifying a (split) bin during a
</span><span class=cm>     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
</span><span class=cm>     * most 6 to mesh with shrinkage detection under removal.
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>UNTREEIFY_THRESHOLD</span> <span class=o>=</span> <span class=n>6</span><span class=p>;</span>

    <span class=cm>/**
</span><span class=cm>     * hashmap整体容量大于这个值时才能树化
</span><span class=cm>     * The smallest table capacity for which bins may be treeified.
</span><span class=cm>     * (Otherwise the table is resized if too many nodes in a bin.)
</span><span class=cm>     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
</span><span class=cm>     * between resizing and treeification thresholds.
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>MIN_TREEIFY_CAPACITY</span> <span class=o>=</span> <span class=n>64</span><span class=p>;</span>
    
    <span class=cm>/**
</span><span class=cm>     * node节点
</span><span class=cm>     * Basic hash bin node, used for most entries.  (See below for
</span><span class=cm>     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>class</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>implements</span> <span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=p>{</span>
        <span class=kd>final</span> <span class=nf>int</span> <span class=n>hash</span><span class=p>;</span>
        <span class=kd>final</span> <span class=nf>K</span> <span class=n>key</span><span class=p>;</span>
        <span class=n>V</span> <span class=nf>value</span><span class=p>;</span>
        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>next</span><span class=p>;</span>

        <span class=n>Node</span><span class=p>(</span><span class=kt>int</span> <span class=nf>hash</span><span class=p>,</span> <span class=n>K</span> <span class=nf>key</span><span class=p>,</span> <span class=n>V</span> <span class=nf>value</span><span class=p>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>next</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>this</span><span class=p>.</span><span class=na>hash</span> <span class=o>=</span> <span class=n>hash</span><span class=p>;</span>
            <span class=k>this</span><span class=p>.</span><span class=na>key</span> <span class=o>=</span> <span class=n>key</span><span class=p>;</span>
            <span class=k>this</span><span class=p>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
            <span class=k>this</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=kd>public</span> <span class=nf>final</span> <span class=n>K</span> <span class=nf>getKey</span><span class=p>()</span>        <span class=p>{</span> <span class=k>return</span> <span class=n>key</span><span class=p>;</span> <span class=p>}</span>
        <span class=kd>public</span> <span class=nf>final</span> <span class=n>V</span> <span class=nf>getValue</span><span class=p>()</span>      <span class=p>{</span> <span class=k>return</span> <span class=n>value</span><span class=p>;</span> <span class=p>}</span>
        <span class=kd>public</span> <span class=nf>final</span> <span class=n>String</span> <span class=nf>toString</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>key</span> <span class=o>+</span> <span class=s>&#34;=&#34;</span> <span class=o>+</span> <span class=n>value</span><span class=p>;</span> <span class=p>}</span>

        <span class=kd>public</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>hashCode</span><span class=p>()</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>Objects</span><span class=p>.</span><span class=na>hashCode</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>^</span> <span class=n>Objects</span><span class=p>.</span><span class=na>hashCode</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
        <span class=p>}</span>
	
        <span class=kd>public</span> <span class=nf>final</span> <span class=n>V</span> <span class=nf>setValue</span><span class=p>(</span><span class=n>V</span> <span class=nf>newValue</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>V</span> <span class=nf>oldValue</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
            <span class=n>value</span> <span class=o>=</span> <span class=n>newValue</span><span class=p>;</span>
            <span class=k>return</span> <span class=n>oldValue</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=kd>public</span> <span class=nf>final</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=p>(</span><span class=n>Object</span> <span class=nf>o</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>o</span> <span class=o>==</span> <span class=k>this</span><span class=p>)</span>
                <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>o</span> <span class=nf>instanceof</span> <span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;?</span><span class=p>,</span><span class=o>?&gt;</span> <span class=n>e</span> <span class=o>=</span> <span class=p>(</span><span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;?</span><span class=p>,</span><span class=o>?&gt;</span><span class=p>)</span><span class=n>o</span><span class=p>;</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>Objects</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=na>getKey</span><span class=p>())</span> <span class=o>&amp;&amp;</span>
                    <span class=n>Objects</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=na>getValue</span><span class=p>()))</span>
                    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>//hashMap中的静态方法
</span><span class=c1></span>    <span class=cm>/**
</span><span class=cm>     * hash方法详解 blog:http://www.hollischuang.com/archives/2091
</span><span class=cm>     * 扰动算法--使hash分布更均匀
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>hash</span><span class=p>(</span><span class=n>Object</span> <span class=nf>key</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=nf>h</span><span class=p>;</span>
        <span class=k>return</span> <span class=p>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=o>?</span> <span class=n>0</span> <span class=o>:</span> <span class=p>(</span><span class=n>h</span> <span class=o>=</span> <span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>())</span> <span class=o>^</span> <span class=p>(</span><span class=n>h</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=p>);</span>
    <span class=p>}</span>
    
    <span class=c1>//取模运算,获得对象存储到bukets的下标
</span><span class=c1></span>    <span class=c1>//实际上就是取模,一般取模使用% 但是考虑到效率问题,采用位运算
</span><span class=c1></span>    <span class=c1>//X % 2^n = X &amp; (2^n-1) 这也是为什么hashmap容量为2的n次方的原因
</span><span class=c1></span>    <span class=kd>static</span> <span class=nf>int</span> <span class=n>indexFor</span><span class=p>(</span><span class=kt>int</span> <span class=nf>h</span><span class=p>,</span> <span class=kt>int</span> <span class=nf>length</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>return</span> <span class=n>h</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>length</span><span class=o>-</span><span class=n>1</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=c1>//返回hashmap的容量 2的n次方 很巧妙的位运算
</span><span class=c1></span>    <span class=kd>static</span> <span class=nf>final</span> <span class=kt>int</span> <span class=nf>tableSizeFor</span><span class=p>(</span><span class=kt>int</span> <span class=nf>cap</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=nf>n</span> <span class=o>=</span> <span class=n>cap</span> <span class=o>-</span> <span class=n>1</span><span class=p>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>1</span><span class=p>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>2</span><span class=p>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>4</span><span class=p>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>8</span><span class=p>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=p>;</span>
        <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>1</span> <span class=o>:</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>)</span> <span class=o>?</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>:</span> <span class=n>n</span> <span class=o>+</span> <span class=n>1</span><span class=p>;</span>
    <span class=p>}</span>
    
    <span class=cm>/**
</span><span class=cm>     * 参数都用transient不让序列化的原因:https://segmentfault.com/q/1010000000630486
</span><span class=cm>     */</span>

    <span class=c1>//bukets hashmap是链表加数组的结构.此为数组
</span><span class=c1></span>    <span class=kd>transient</span> <span class=nf>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>table</span><span class=p>;</span>
    
    <span class=c1>//保存键值对的Entry
</span><span class=c1></span>    <span class=kd>transient</span> <span class=nf>Set</span><span class=o>&lt;</span><span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;&gt;</span> <span class=nf>entrySet</span><span class=p>;</span>
    
    <span class=c1>//hashmap的size
</span><span class=c1></span>    <span class=kd>transient</span> <span class=nf>int</span> <span class=n>size</span><span class=p>;</span>
    
    <span class=c1>//结构操作次数 可用于快速失败的比较条件 例如并发操作时
</span><span class=c1></span>    <span class=kd>transient</span> <span class=nf>int</span> <span class=n>modCount</span><span class=p>;</span>
    
    <span class=c1>//resize的临界点: capacity * load factor 
</span><span class=c1></span>    <span class=kt>int</span> <span class=nf>threshold</span><span class=p>;</span>
    
    <span class=c1>//加载因子
</span><span class=c1></span>    <span class=kd>final</span> <span class=nf>float</span> <span class=n>loadFactor</span><span class=p>;</span>

    <span class=c1>//公有操作方法
</span><span class=c1></span>
    <span class=c1>//构造方法
</span><span class=c1></span>    <span class=cm>/**
</span><span class=cm>     * 根据 initial capactity 和 loadFactor创建空的hashmap
</span><span class=cm>     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
</span><span class=cm>     * capacity and load factor.
</span><span class=cm>     *
</span><span class=cm>     * @param  initialCapacity the initial capacity
</span><span class=cm>     * @param  loadFactor      the load factor
</span><span class=cm>     * @throws IllegalArgumentException if the initial capacity is negative
</span><span class=cm>     *         or the load factor is nonpositive
</span><span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>HashMap</span><span class=p>(</span><span class=kt>int</span> <span class=nf>initialCapacity</span><span class=p>,</span> <span class=kt>float</span> <span class=nf>loadFactor</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>//校验initialCapacity
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=n>0</span><span class=p>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s>&#34;Illegal initial capacity: &#34;</span> <span class=o>+</span>
                                               <span class=n>initialCapacity</span><span class=p>);</span>
	<span class=c1>//容量校验
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>initialCapacity</span> <span class=o>&gt;</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>)</span>
            <span class=n>initialCapacity</span> <span class=o>=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>;</span>
	<span class=c1>//校验loadFactor isNaN--&gt; 是否是一个number Not-a-Number
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>loadFactor</span> <span class=o>&lt;=</span> <span class=n>0</span> <span class=o>||</span> <span class=n>Float</span><span class=p>.</span><span class=na>isNaN</span><span class=p>(</span><span class=n>loadFactor</span><span class=p>))</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s>&#34;Illegal load factor: &#34;</span> <span class=o>+</span>
                                               <span class=n>loadFactor</span><span class=p>);</span>
	<span class=c1>//加载因子赋值
</span><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>loadFactor</span><span class=p>;</span>
	<span class=c1>//扩容阈值赋值 2的n次方
</span><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=na>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=p>(</span><span class=n>initialCapacity</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=cm>/**
</span><span class=cm>     * 通过initialCapacity赋值
</span><span class=cm>     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
</span><span class=cm>     * capacity and the default load factor (0.75).
</span><span class=cm>     *
</span><span class=cm>     * @param  initialCapacity the initial capacity.
</span><span class=cm>     * @throws IllegalArgumentException if the initial capacity is negative.
</span><span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>HashMap</span><span class=p>(</span><span class=kt>int</span> <span class=nf>initialCapacity</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>this</span><span class=p>(</span><span class=n>initialCapacity</span><span class=p>,</span> <span class=n>DEFAULT_LOAD_FACTOR</span><span class=p>);</span>
    <span class=p>}</span>
    
    <span class=cm>/**
</span><span class=cm>     * 根据默认容量和默认加载因子创建空的hashmap
</span><span class=cm>     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
</span><span class=cm>     * (16) and the default load factor (0.75).
</span><span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>HashMap</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>this</span><span class=p>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>DEFAULT_LOAD_FACTOR</span><span class=p>;</span> <span class=c1>// all other fields defaulted
</span><span class=c1></span>    <span class=p>}</span>

    <span class=cm>/**
</span><span class=cm>     * 根据传进来的map创建一个新的hashMap 
</span><span class=cm>     * initialCapacity 足以装下参数map的数量
</span><span class=cm>     * loadFactor使用默认值
</span><span class=cm>     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
</span><span class=cm>     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
</span><span class=cm>     * default load factor (0.75) and an initial capacity sufficient to
</span><span class=cm>     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
</span><span class=cm>     *
</span><span class=cm>     * @param   m the map whose mappings are to be placed in this map
</span><span class=cm>     * @throws  NullPointerException if the specified map is null
</span><span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>HashMap</span><span class=p>(</span><span class=n>Map</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=nf>K</span><span class=p>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=nf>V</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>this</span><span class=p>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>DEFAULT_LOAD_FACTOR</span><span class=p>;</span>
        <span class=n>putMapEntries</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=kc>false</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=cm>/**
</span><span class=cm>     * Implements Map.putAll and Map constructor
</span><span class=cm>     *
</span><span class=cm>     * @param m the map
</span><span class=cm>     * @param evict false when initially constructing this map, else
</span><span class=cm>     * true (relayed to method afterNodeInsertion).
</span><span class=cm>     * evict 初始化构建map时 为false 其他情况下为true
</span><span class=cm>     */</span>
    <span class=kd>final</span> <span class=nf>void</span> <span class=n>putMapEntries</span><span class=p>(</span><span class=n>Map</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=nf>K</span><span class=p>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=nf>V</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>,</span> <span class=kt>boolean</span> <span class=nf>evict</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=nf>s</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=na>size</span><span class=p>();</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&gt;</span> <span class=n>0</span><span class=p>)</span> <span class=p>{</span>
	    <span class=c1>//初次创建hashmap
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>table</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// pre-size
</span><span class=c1></span>		<span class=c1>//计算m所需要的容量
</span><span class=c1></span>                <span class=kt>float</span> <span class=nf>ft</span> <span class=o>=</span> <span class=p>((</span><span class=kt>float</span><span class=p>)</span><span class=n>s</span> <span class=o>/</span> <span class=n>loadFactor</span><span class=p>)</span> <span class=o>+</span> <span class=n>1</span><span class=p>.</span><span class=na>0F</span><span class=p>;</span>
		<span class=c1>//获得真实的容量
</span><span class=c1></span>                <span class=kt>int</span> <span class=nf>t</span> <span class=o>=</span> <span class=p>((</span><span class=n>ft</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>MAXIMUM_CAPACITY</span><span class=p>)</span> <span class=o>?</span>
                         <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>ft</span> <span class=o>:</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>);</span>
		<span class=c1>//如果比默认的阈值大则计算该 t 对应的capacity
</span><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>t</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span>
                    <span class=n>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span> <span class=c1>// 如果是table不为null 即是后续往map中添加 如果s &gt; 阈值就要重置map了
</span><span class=c1></span>                <span class=n>resize</span><span class=p>();</span><span class=c1>//resize操作 后面介绍
</span><span class=c1></span>	    <span class=c1>//确定容量后put操作
</span><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=nf>K</span><span class=p>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=nf>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>:</span> <span class=n>m</span><span class=p>.</span><span class=na>entrySet</span><span class=p>())</span> <span class=p>{</span>
                <span class=n>K</span> <span class=nf>key</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>getKey</span><span class=p>();</span>
                <span class=n>V</span> <span class=nf>value</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>getValue</span><span class=p>();</span>
                <span class=n>putVal</span><span class=p>(</span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>),</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=n>evict</span><span class=p>);</span><span class=c1>//
</span><span class=c1></span>            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=cm>/*主要调用 putVal */</span>
    <span class=kd>public</span> <span class=nf>V</span> <span class=n>put</span><span class=p>(</span><span class=n>K</span> <span class=nf>key</span><span class=p>,</span> <span class=n>V</span> <span class=nf>value</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>putVal</span><span class=p>(</span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>),</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>true</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=cm>/**
</span><span class=cm>     * put 操作
</span><span class=cm>     * Implements Map.put and related methods
</span><span class=cm>     *
</span><span class=cm>     * @param hash hash for key
</span><span class=cm>     * @param key the key
</span><span class=cm>     * @param value the value to put
</span><span class=cm>     * @param onlyIfAbsent if true, don&#39;t change existing value 不存在才put&lt;D-[&gt;
</span><span class=cm>     * @param evict if false, the table is in creation mode.
</span><span class=cm>     * @return previous value, or null if none
</span><span class=cm>     */</span>
    <span class=kd>final</span> <span class=nf>V</span> <span class=n>putVal</span><span class=p>(</span><span class=kt>int</span> <span class=nf>hash</span><span class=p>,</span> <span class=n>K</span> <span class=nf>key</span><span class=p>,</span> <span class=n>V</span> <span class=nf>value</span><span class=p>,</span> <span class=kt>boolean</span> <span class=nf>onlyIfAbsent</span><span class=p>,</span>
                   <span class=kt>boolean</span> <span class=nf>evict</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>tab</span><span class=p>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>p</span><span class=p>;</span> <span class=kt>int</span> <span class=nf>n</span><span class=p>,</span> <span class=n>i</span><span class=p>;</span>
	<span class=c1>//若是新建map的情况下 resize创建指定长度的table 
</span><span class=c1></span>        <span class=k>if</span> <span class=p>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=p>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=p>.</span><span class=na>length</span><span class=p>)</span> <span class=o>==</span> <span class=n>0</span><span class=p>)</span>
            <span class=n>n</span> <span class=o>=</span> <span class=p>(</span><span class=n>tab</span> <span class=o>=</span> <span class=n>resize</span><span class=p>()).</span><span class=na>length</span><span class=p>;</span>
	<span class=c1>//取模计算该key对应的数组下标 并判断该坐标下的对象是否为null
</span><span class=c1></span>	<span class=c1>//为null时创建一个新node存入tab[i]
</span><span class=c1></span>        <span class=k>if</span> <span class=p>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>tab</span><span class=p>[</span><span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=p>])</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span>
            <span class=n>tab</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>(</span><span class=n>hash</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span>
        <span class=k>else</span> <span class=p>{</span><span class=c1>//tab[i] != null
</span><span class=c1></span>            <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>e</span><span class=p>;</span> <span class=n>K</span> <span class=nf>k</span><span class=p>;</span>
	    <span class=c1>//如果p与存入的key完全相同
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
                <span class=p>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>key</span><span class=p>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=p>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>k</span><span class=p>))))</span>
                <span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=nf>instanceof</span> <span class=n>TreeNode</span><span class=p>)</span>
		<span class=c1>//如果是红黑树节点 调用putTreeVal
</span><span class=c1></span>                <span class=n>e</span> <span class=o>=</span> <span class=p>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=n>p</span><span class=p>).</span><span class=na>putTreeVal</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>tab</span><span class=p>,</span> <span class=n>hash</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
            <span class=k>else</span> <span class=p>{</span>
		<span class=c1>//普通的put
</span><span class=c1></span>		<span class=c1>//binCount记录了链表的长度
</span><span class=c1></span>                <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nf>binCount</span> <span class=o>=</span> <span class=n>0</span><span class=p>;</span> <span class=p>;</span> <span class=o>++</span><span class=n>binCount</span><span class=p>)</span> <span class=p>{</span>
		    <span class=c1>//如果当前node的next==null说明就可以往该链上添加一个节点
</span><span class=c1></span>                    <span class=k>if</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>next</span><span class=p>)</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
			<span class=c1>//新建node接到p.next下面
</span><span class=c1></span>                        <span class=n>p</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>(</span><span class=n>hash</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span>
			<span class=c1>//如果binCount大于设定的红黑树化阈值
</span><span class=c1></span>                        <span class=k>if</span> <span class=p>(</span><span class=n>binCount</span> <span class=o>&gt;=</span> <span class=n>TREEIFY_THRESHOLD</span> <span class=o>-</span> <span class=n>1</span><span class=p>)</span> <span class=c1>// -1 for 1st
</span><span class=c1></span>                            <span class=n>treeifyBin</span><span class=p>(</span><span class=n>tab</span><span class=p>,</span> <span class=n>hash</span><span class=p>);</span><span class=c1>//红黑树化
</span><span class=c1></span>                        <span class=k>break</span><span class=p>;</span>
                    <span class=p>}</span>
		    <span class=c1>//如果key与链表中的任意node完全相同break
</span><span class=c1></span>                    <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
                        <span class=p>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>key</span><span class=p>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=p>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>k</span><span class=p>))))</span>
                        <span class=k>break</span><span class=p>;</span>
                    <span class=n>p</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
	    <span class=c1>//如果存在该key
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// existing mapping for key
</span><span class=c1></span>                <span class=n>V</span> <span class=nf>oldValue</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>value</span><span class=p>;</span><span class=c1>//获得旧值
</span><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>onlyIfAbsent</span> <span class=o>||</span> <span class=n>oldValue</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span><span class=c1>//若没有设置不存在才put或者oldValue=null
</span><span class=c1></span>                    <span class=n>e</span><span class=p>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span><span class=c1>//赋新值
</span><span class=c1></span>                <span class=n>afterNodeAccess</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=c1>//LinkedHashMap操作
</span><span class=c1></span>                <span class=k>return</span> <span class=n>oldValue</span><span class=p>;</span><span class=c1>//返回旧值
</span><span class=c1></span>            <span class=p>}</span>
        <span class=p>}</span>
        <span class=o>++</span><span class=n>modCount</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>++</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span><span class=c1>//是否需要扩容
</span><span class=c1></span>            <span class=n>resize</span><span class=p>();</span>
        <span class=n>afterNodeInsertion</span><span class=p>(</span><span class=n>evict</span><span class=p>);</span><span class=c1>//LinkedHashMap操作
</span><span class=c1></span>        <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/**
</span><span class=cm>     * 扩容操作
</span><span class=cm>     * 若是初始化则根据initialCapacity创建一个table
</span><span class=cm>     * 否则,扩容为2的n次方倍
</span><span class=cm>     * Initializes or doubles table size.  If null, allocates in
</span><span class=cm>     * accord with initial capacity target held in field threshold.
</span><span class=cm>     * Otherwise, because we are using power-of-two expansion, the
</span><span class=cm>     * elements from each bin must either stay at same index, or move
</span><span class=cm>     * with a power of two offset in the new table.
</span><span class=cm>     *
</span><span class=cm>     * @return the table
</span><span class=cm>     */</span>
    <span class=kd>final</span> <span class=nf>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>resize</span><span class=p>()</span> <span class=p>{</span>
        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>oldTab</span> <span class=o>=</span> <span class=n>table</span><span class=p>;</span>
        <span class=kt>int</span> <span class=nf>oldCap</span> <span class=o>=</span> <span class=p>(</span><span class=n>oldTab</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=o>?</span> <span class=n>0</span> <span class=o>:</span> <span class=n>oldTab</span><span class=p>.</span><span class=na>length</span><span class=p>;</span>
        <span class=kt>int</span> <span class=nf>oldThr</span> <span class=o>=</span> <span class=n>threshold</span><span class=p>;</span>
        <span class=kt>int</span> <span class=nf>newCap</span><span class=p>,</span> <span class=n>newThr</span> <span class=o>=</span> <span class=n>0</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>oldCap</span> <span class=o>&gt;</span> <span class=n>0</span><span class=p>)</span> <span class=p>{</span>
	    <span class=c1>//超过最大值不会再扩容了
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>threshold</span> <span class=o>=</span> <span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=p>;</span>
                <span class=k>return</span> <span class=n>oldTab</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>newCap</span> <span class=o>=</span> <span class=n>oldCap</span> <span class=o>&lt;&lt;</span> <span class=n>1</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span>
                     <span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=p>)</span>
                <span class=n>newThr</span> <span class=o>=</span> <span class=n>oldThr</span> <span class=o>&lt;&lt;</span> <span class=n>1</span><span class=p>;</span> <span class=c1>// double threshold 扩成两倍
</span><span class=c1></span>        <span class=p>}</span>
        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>oldThr</span> <span class=o>&gt;</span> <span class=n>0</span><span class=p>)</span> <span class=c1>// initial capacity was placed in threshold
</span><span class=c1></span>            <span class=n>newCap</span> <span class=o>=</span> <span class=n>oldThr</span><span class=p>;</span>
        <span class=k>else</span> <span class=p>{</span>               <span class=c1>// 默认配置 zero initial threshold signifies using defaults
</span><span class=c1></span>            <span class=n>newCap</span> <span class=o>=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=p>;</span>
            <span class=n>newThr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)(</span><span class=n>DEFAULT_LOAD_FACTOR</span> <span class=o>*</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>newThr</span> <span class=o>==</span> <span class=n>0</span><span class=p>)</span> <span class=p>{</span>
	    <span class=c1>//计算新的阈值
</span><span class=c1></span>            <span class=kt>float</span> <span class=nf>ft</span> <span class=o>=</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>newCap</span> <span class=o>*</span> <span class=n>loadFactor</span><span class=p>;</span>
            <span class=n>newThr</span> <span class=o>=</span> <span class=p>(</span><span class=n>newCap</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span> <span class=n>ft</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>MAXIMUM_CAPACITY</span> <span class=o>?</span>
                      <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>ft</span> <span class=o>:</span> <span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=n>threshold</span> <span class=o>=</span> <span class=n>newThr</span><span class=p>;</span>
        <span class=nd>@SuppressWarnings</span><span class=p>({</span><span class=s>&#34;rawtypes&#34;</span><span class=p>,</span><span class=s>&#34;unchecked&#34;</span><span class=p>})</span>
            <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>newTab</span> <span class=o>=</span> <span class=p>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[])</span><span class=k>new</span> <span class=n>Node</span><span class=p>[</span><span class=n>newCap</span><span class=p>];</span>
        <span class=n>table</span> <span class=o>=</span> <span class=n>newTab</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>oldTab</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
	    <span class=c1>//把old buket 移到新的bukets里
</span><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nf>j</span> <span class=o>=</span> <span class=n>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>oldCap</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>e</span><span class=p>;</span>
                <span class=k>if</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>oldTab</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>oldTab</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=na>next</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span><span class=c1>//直接添加
</span><span class=c1></span>                        <span class=n>newTab</span><span class=p>[</span><span class=n>e</span><span class=p>.</span><span class=na>hash</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>newCap</span> <span class=o>-</span> <span class=n>1</span><span class=p>)]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
                    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>e</span> <span class=nf>instanceof</span> <span class=n>TreeNode</span><span class=p>)</span>
                        <span class=p>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=n>e</span><span class=p>).</span><span class=na>split</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>newTab</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>oldCap</span><span class=p>);</span>
                    <span class=k>else</span> <span class=p>{</span> <span class=c1>// preserve order
</span><span class=c1></span>                        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>loHead</span> <span class=o>=</span> <span class=kc>null</span><span class=p>,</span> <span class=n>loTail</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>hiHead</span> <span class=o>=</span> <span class=kc>null</span><span class=p>,</span> <span class=n>hiTail</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>next</span><span class=p>;</span>
                        <span class=k>do</span> <span class=p>{</span>
                            <span class=n>next</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>next</span><span class=p>;</span>
			    <span class=c1>//这个取模很精辟 请结合美团的blog resize 1.8优化学习
</span><span class=c1></span>			    <span class=c1>//因为扩容是2倍扩容,二进制中相当于左移一位
</span><span class=c1></span>			    <span class=cm>/**
</span><span class=cm>			     * 假设一次扩容		    
</span><span class=cm>			     * 扩容前	oldCap = 00010000   oldCap - 1 = 00001111
</span><span class=cm>			     * 扩容后	newCap = 00100000   newCap - 1 = 00011111
</span><span class=cm>			     * 可以看出扩容后 newCap-1 在高位多了1
</span><span class=cm>			     * 计算index时 hash &amp; n-1 = 原位置 + oldCap
</span><span class=cm>			     * 所以只需要判断hash &amp; oldCap是否为1
</span><span class=cm>			     * 为1则把该node的位置移到 oldCap+原位置 
</span><span class=cm>			     * 为 0 还在原位置
</span><span class=cm>			     */</span>
                            <span class=k>if</span> <span class=p>((</span><span class=n>e</span><span class=p>.</span><span class=na>hash</span> <span class=o>&amp;</span> <span class=n>oldCap</span><span class=p>)</span> <span class=o>==</span> <span class=n>0</span><span class=p>)</span> <span class=p>{</span><span class=c1>//为0说明位置没有变
</span><span class=c1></span>                                <span class=k>if</span> <span class=p>(</span><span class=n>loTail</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span><span class=c1>//第一次添加时loHead=e
</span><span class=c1></span>                                    <span class=n>loHead</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
                                <span class=k>else</span>
                                    <span class=n>loTail</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span><span class=c1>//直接往后插入
</span><span class=c1></span>                                <span class=n>loTail</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
                            <span class=p>}</span>
                            <span class=k>else</span> <span class=p>{</span><span class=c1>//为1 说明位置会+oldCap长度
</span><span class=c1></span>                                <span class=k>if</span> <span class=p>(</span><span class=n>hiTail</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span>
                                    <span class=n>hiHead</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span><span class=c1>//头节点初始化
</span><span class=c1></span>                                <span class=k>else</span>
                                    <span class=n>hiTail</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span><span class=c1>//直接插入
</span><span class=c1></span>                                <span class=n>hiTail</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
                            <span class=p>}</span>
                        <span class=p>}</span> <span class=k>while</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>next</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>);</span>
                        <span class=k>if</span> <span class=p>(</span><span class=n>loTail</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span><span class=c1>//放在原位置上
</span><span class=c1></span>                            <span class=n>loTail</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                            <span class=n>newTab</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>loHead</span><span class=p>;</span>
                        <span class=p>}</span>
                        <span class=k>if</span> <span class=p>(</span><span class=n>hiTail</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span><span class=c1>//放在原位置+oldCap上
</span><span class=c1></span>                            <span class=n>hiTail</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                            <span class=n>newTab</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>oldCap</span><span class=p>]</span> <span class=o>=</span> <span class=n>hiHead</span><span class=p>;</span>
                        <span class=p>}</span>
                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=n>newTab</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/**
</span><span class=cm>     * get操作
</span><span class=cm>     * 为null时返回null 这个要注意下
</span><span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>V</span> <span class=n>get</span><span class=p>(</span><span class=n>Object</span> <span class=nf>key</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>e</span><span class=p>;</span>
        <span class=k>return</span> <span class=p>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>getNode</span><span class=p>(</span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>),</span> <span class=n>key</span><span class=p>))</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>e</span><span class=p>.</span><span class=na>value</span><span class=p>;</span>
    <span class=p>}</span>


    <span class=cm>/**
</span><span class=cm>     * Implements Map.get and related methods
</span><span class=cm>     * get方法
</span><span class=cm>     * 主要是   key相等 或者 key equals的比较
</span><span class=cm>     * @param hash hash for key
</span><span class=cm>     * @param key the key
</span><span class=cm>     * @return the node, or null if none
</span><span class=cm>     */</span>
    <span class=kd>final</span> <span class=nf>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>getNode</span><span class=p>(</span><span class=kt>int</span> <span class=nf>hash</span><span class=p>,</span> <span class=n>Object</span> <span class=nf>key</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>tab</span><span class=p>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>first</span><span class=p>,</span> <span class=n>e</span><span class=p>;</span> <span class=kt>int</span> <span class=nf>n</span><span class=p>;</span> <span class=n>K</span> <span class=nf>k</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=p>.</span><span class=na>length</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>0</span> <span class=o>&amp;&amp;</span>
            <span class=p>(</span><span class=n>first</span> <span class=o>=</span> <span class=n>tab</span><span class=p>[(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=p>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span><span class=c1>//获得节点
</span><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>first</span><span class=p>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span> <span class=c1>// always check first node
</span><span class=c1></span>                <span class=p>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>first</span><span class=p>.</span><span class=na>key</span><span class=p>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=p>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>k</span><span class=p>))))</span>
                <span class=k>return</span> <span class=n>first</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>first</span><span class=p>.</span><span class=na>next</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>first</span> <span class=nf>instanceof</span> <span class=n>TreeNode</span><span class=p>)</span><span class=c1>//树节点
</span><span class=c1></span>                    <span class=k>return</span> <span class=p>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=n>first</span><span class=p>).</span><span class=na>getTreeNode</span><span class=p>(</span><span class=n>hash</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
                <span class=k>do</span> <span class=p>{</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
                        <span class=p>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>key</span><span class=p>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=p>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>k</span><span class=p>))))</span>
                        <span class=k>return</span> <span class=n>e</span><span class=p>;</span>
                <span class=p>}</span> <span class=k>while</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>next</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=1-8红黑树化源码解析></a><h2>1.8红黑树化源码解析</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>    <span class=cm>/**
</span><span class=cm>     * TreeNode extends LinkedHashMap.Entry
</span><span class=cm>     * LinkedHashMap.Entry extends HashMap.Node
</span><span class=cm>     */</span>

    <span class=kd>static</span> <span class=nf>final</span> <span class=kd>class</span> <span class=nf>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>extends</span> <span class=n>LinkedHashMap</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=p>{</span>
        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>parent</span><span class=p>;</span>  <span class=c1>// red-black tree links 红黑树父节点
</span><span class=c1></span>        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>left</span><span class=p>;</span>
        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>right</span><span class=p>;</span>
        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>prev</span><span class=p>;</span>    <span class=c1>// needed to unlink next upon deletion 删除的时候用来连接前后
</span><span class=c1></span>        <span class=kt>boolean</span> <span class=nf>red</span><span class=p>;</span><span class=c1>//红还是黑
</span><span class=c1></span>        <span class=n>TreeNode</span><span class=p>(</span><span class=kt>int</span> <span class=nf>hash</span><span class=p>,</span> <span class=n>K</span> <span class=nf>key</span><span class=p>,</span> <span class=n>V</span> <span class=nf>val</span><span class=p>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>next</span><span class=p>)</span> <span class=p>{</span>
            <span class=kd>super</span><span class=p>(</span><span class=n>hash</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>next</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>     
    
    
    <span class=cm>/**树化
</span><span class=cm>     * putVal里有用到
</span><span class=cm>     * 将链表重置为红黑树并放到该hash映射的tab下,如果tab过下则resize
</span><span class=cm>     * Replaces all linked nodes in bin at index for given hash unless
</span><span class=cm>     * table is too small, in which case resizes instead.
</span><span class=cm>     */</span>
    <span class=kd>final</span> <span class=nf>void</span> <span class=n>treeifyBin</span><span class=p>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>tab</span><span class=p>,</span> <span class=kt>int</span> <span class=nf>hash</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=nf>n</span><span class=p>,</span> <span class=n>index</span><span class=p>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>e</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>tab</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=p>.</span><span class=na>length</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>MIN_TREEIFY_CAPACITY</span><span class=p>)</span><span class=c1>//小于最小树化的容量时不树化而resize  capacity为64,
</span><span class=c1></span>            <span class=n>resize</span><span class=p>();</span>
        <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=p>[</span><span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=p>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>hd</span> <span class=o>=</span> <span class=kc>null</span><span class=p>,</span> <span class=n>tl</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span><span class=c1>//头尾节点
</span><span class=c1></span>            <span class=k>do</span> <span class=p>{</span>
                <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>p</span> <span class=o>=</span> <span class=n>replacementTreeNode</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span><span class=c1>//这个就是返回一个新建的TreeNode对象,内容为e
</span><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>tl</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span><span class=c1>//确定是头结点
</span><span class=c1></span>                    <span class=n>hd</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span><span class=c1>//标记头结点
</span><span class=c1></span>                <span class=k>else</span> <span class=p>{</span><span class=c1>//非头结点就首尾连接
</span><span class=c1></span>                    <span class=n>p</span><span class=p>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>tl</span><span class=p>;</span>
                    <span class=n>tl</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=n>tl</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span><span class=c1>//尾节点一直为p
</span><span class=c1></span>            <span class=p>}</span> <span class=k>while</span> <span class=p>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=na>next</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>);</span><span class=c1>//遍历链表 其实此时形成也还算是个链表
</span><span class=c1></span>            <span class=k>if</span> <span class=p>((</span><span class=n>tab</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>hd</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span><span class=c1>//将该treeNode挂到table下
</span><span class=c1></span>                <span class=n>hd</span><span class=p>.</span><span class=na>treeify</span><span class=p>(</span><span class=n>tab</span><span class=p>);</span><span class=c1>//完成红黑树化
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>}</span>

       <span class=cm>/**
</span><span class=cm>         * Forms tree of the nodes linked from this node.
</span><span class=cm>         * @return root of tree
</span><span class=cm>         */</span>
        <span class=kd>final</span> <span class=nf>void</span> <span class=n>treeify</span><span class=p>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>tab</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>root</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
            <span class=k>for</span> <span class=p>(</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>x</span> <span class=o>=</span> <span class=k>this</span><span class=p>,</span> <span class=n>next</span><span class=p>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>next</span><span class=p>)</span> <span class=p>{</span><span class=c1>//x 从当前节点开始(从treeifyBin里调用看是头结点)
</span><span class=c1></span>                <span class=n>next</span> <span class=o>=</span> <span class=p>(</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=n>x</span><span class=p>.</span><span class=na>next</span><span class=p>;</span><span class=c1>//获取下个节点
</span><span class=c1></span>                <span class=n>x</span><span class=p>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=na>right</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span><span class=c1>//设置root节点并给他黑色
</span><span class=c1></span>                    <span class=n>x</span><span class=p>.</span><span class=na>parent</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                    <span class=n>x</span><span class=p>.</span><span class=na>red</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
                    <span class=n>root</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=k>else</span> <span class=p>{</span>
                    <span class=n>K</span> <span class=nf>k</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=na>key</span><span class=p>;</span>
                    <span class=kt>int</span> <span class=nf>h</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=na>hash</span><span class=p>;</span>
                    <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>kc</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
                    <span class=c1>//遍历所有节点与当前节点x比较 调整位置 有点像冒泡排序
</span><span class=c1></span>                    <span class=k>for</span> <span class=p>(</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>p</span> <span class=o>=</span> <span class=n>root</span><span class=p>;;)</span> <span class=p>{</span>
                        <span class=kt>int</span> <span class=nf>dir</span><span class=p>,</span> <span class=n>ph</span><span class=p>;</span>
                        <span class=n>K</span> <span class=nf>pk</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>key</span><span class=p>;</span>
                        <span class=c1>//比较hash值
</span><span class=c1></span>                        <span class=k>if</span> <span class=p>((</span><span class=n>ph</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>hash</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>h</span><span class=p>)</span>
                            <span class=n>dir</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=p>;</span>
                        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>ph</span> <span class=o>&lt;</span> <span class=n>h</span><span class=p>)</span>
                            <span class=n>dir</span> <span class=o>=</span> <span class=n>1</span><span class=p>;</span>
                        <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>kc</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span>
                                  <span class=p>(</span><span class=n>kc</span> <span class=o>=</span> <span class=n>comparableClassFor</span><span class=p>(</span><span class=n>k</span><span class=p>))</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=o>||</span>
                                 <span class=p>(</span><span class=n>dir</span> <span class=o>=</span> <span class=n>compareComparables</span><span class=p>(</span><span class=n>kc</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>pk</span><span class=p>))</span> <span class=o>==</span> <span class=n>0</span><span class=p>)</span>
                            <span class=n>dir</span> <span class=o>=</span> <span class=n>tieBreakOrder</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>pk</span><span class=p>);</span>
                        
                        <span class=c1>//根据dir判断x是p的左孩子 还是 右孩子
</span><span class=c1></span>                        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>xp</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
                        <span class=k>if</span> <span class=p>((</span><span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=n>dir</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>p</span><span class=p>.</span><span class=na>left</span> <span class=o>:</span> <span class=n>p</span><span class=p>.</span><span class=na>right</span><span class=p>)</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                            <span class=n>x</span><span class=p>.</span><span class=na>parent</span> <span class=o>=</span> <span class=n>xp</span><span class=p>;</span>
                            <span class=k>if</span> <span class=p>(</span><span class=n>dir</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=p>)</span>
                                <span class=n>xp</span><span class=p>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
                            <span class=k>else</span>
                                <span class=n>xp</span><span class=p>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
                            <span class=c1>//平衡节点
</span><span class=c1></span>                            <span class=n>root</span> <span class=o>=</span> <span class=n>balanceInsertion</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
                            <span class=k>break</span><span class=p>;</span>
                        <span class=p>}</span>
                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>}</span>
            <span class=n>moveRootToFront</span><span class=p>(</span><span class=n>tab</span><span class=p>,</span> <span class=n>root</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=cm>/**
</span><span class=cm>         * Returns a list of non-TreeNodes replacing those linked from
</span><span class=cm>         * this node.
</span><span class=cm>         */</span>
        <span class=kd>final</span> <span class=nf>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>untreeify</span><span class=p>(</span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>map</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>hd</span> <span class=o>=</span> <span class=kc>null</span><span class=p>,</span> <span class=n>tl</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
            <span class=k>for</span> <span class=p>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>q</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span> <span class=n>q</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>;</span> <span class=n>q</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=na>next</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>p</span> <span class=o>=</span> <span class=n>map</span><span class=p>.</span><span class=na>replacementNode</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>tl</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span>
                    <span class=n>hd</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
                <span class=k>else</span>
                    <span class=n>tl</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
                <span class=n>tl</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>return</span> <span class=n>hd</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=cm>/**
</span><span class=cm>         * 红黑树版put操作
</span><span class=cm>         * Tree version of putVal.
</span><span class=cm>         */</span>
        <span class=kd>final</span> <span class=nf>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>putTreeVal</span><span class=p>(</span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>map</span><span class=p>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>[]</span> <span class=nf>tab</span><span class=p>,</span>
                                       <span class=kt>int</span> <span class=nf>h</span><span class=p>,</span> <span class=n>K</span> <span class=nf>k</span><span class=p>,</span> <span class=n>V</span> <span class=nf>v</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>kc</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
            <span class=kt>boolean</span> <span class=nf>searched</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
            <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>root</span> <span class=o>=</span> <span class=p>(</span><span class=n>parent</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=o>?</span> <span class=n>root</span><span class=p>()</span> <span class=o>:</span> <span class=k>this</span><span class=p>;</span><span class=c1>//每次从根节点遍历
</span><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>p</span> <span class=o>=</span> <span class=n>root</span><span class=p>;;)</span> <span class=p>{</span>
                <span class=kt>int</span> <span class=nf>dir</span><span class=p>,</span> <span class=n>ph</span><span class=p>;</span> <span class=n>K</span> <span class=nf>pk</span><span class=p>;</span>
                <span class=k>if</span> <span class=p>((</span><span class=n>ph</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>hash</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>h</span><span class=p>)</span>
                    <span class=n>dir</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>ph</span> <span class=o>&lt;</span> <span class=n>h</span><span class=p>)</span>
                    <span class=n>dir</span> <span class=o>=</span> <span class=n>1</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>pk</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>key</span><span class=p>)</span> <span class=o>==</span> <span class=n>k</span> <span class=o>||</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>k</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>pk</span><span class=p>)))</span>
                    <span class=c1>//如果当前节点key相同或equals 返回
</span><span class=c1></span>                    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>kc</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span>
                          <span class=p>(</span><span class=n>kc</span> <span class=o>=</span> <span class=n>comparableClassFor</span><span class=p>(</span><span class=n>k</span><span class=p>))</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=o>||</span>
                         <span class=p>(</span><span class=n>dir</span> <span class=o>=</span> <span class=n>compareComparables</span><span class=p>(</span><span class=n>kc</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>pk</span><span class=p>))</span> <span class=o>==</span> <span class=n>0</span><span class=p>)</span> <span class=p>{</span>
                    <span class=c1>//hash值如果相等 但类不相同,只能挨个对比左右孩子
</span><span class=c1></span>                    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>searched</span><span class=p>)</span> <span class=p>{</span>
                        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>q</span><span class=p>,</span> <span class=n>ch</span><span class=p>;</span>
                        <span class=n>searched</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
                        <span class=k>if</span> <span class=p>(((</span><span class=n>ch</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>left</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span>
                             <span class=p>(</span><span class=n>q</span> <span class=o>=</span> <span class=n>ch</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>kc</span><span class=p>))</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=o>||</span>
                            <span class=p>((</span><span class=n>ch</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>right</span><span class=p>)</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span>
                             <span class=p>(</span><span class=n>q</span> <span class=o>=</span> <span class=n>ch</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>kc</span><span class=p>))</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>))</span>
                            <span class=k>return</span> <span class=n>q</span><span class=p>;</span>
                    <span class=p>}</span>
                    <span class=c1>//哈希值相等 但键无法比较 只能通过其他方法比较
</span><span class=c1></span>                    <span class=n>dir</span> <span class=o>=</span> <span class=n>tieBreakOrder</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>pk</span><span class=p>);</span>
                <span class=p>}</span>

                <span class=c1>//得到两个节点的大小关系 即dir的值时
</span><span class=c1></span>                <span class=c1>//并判断只有在左孩子或右孩子不能
</span><span class=c1></span>                <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>xp</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
                <span class=k>if</span> <span class=p>((</span><span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=n>dir</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>p</span><span class=p>.</span><span class=na>left</span> <span class=o>:</span> <span class=n>p</span><span class=p>.</span><span class=na>right</span><span class=p>)</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>xpn</span> <span class=o>=</span> <span class=n>xp</span><span class=p>.</span><span class=na>next</span><span class=p>;</span>
                    <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>x</span> <span class=o>=</span> <span class=n>map</span><span class=p>.</span><span class=na>newTreeNode</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>xpn</span><span class=p>);</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>dir</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=p>)</span>
                        <span class=n>xp</span><span class=p>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
                    <span class=k>else</span>
                        <span class=n>xp</span><span class=p>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
                    <span class=n>xp</span><span class=p>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
                    <span class=n>x</span><span class=p>.</span><span class=na>parent</span> <span class=o>=</span> <span class=n>x</span><span class=p>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>xp</span><span class=p>;</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>xpn</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span>
                        <span class=p>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span><span class=p>)</span><span class=n>xpn</span><span class=p>).</span><span class=na>prev</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
                    <span class=c1>//平衡二叉树
</span><span class=c1></span>                    <span class=n>moveRootToFront</span><span class=p>(</span><span class=n>tab</span><span class=p>,</span> <span class=n>balanceInsertion</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>x</span><span class=p>));</span>
                    <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=cm>/** 查找操作 传入 hash值 和 key值
</span><span class=cm>         * Calls find for root node.
</span><span class=cm>         */</span>
        <span class=kd>final</span> <span class=nf>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>getTreeNode</span><span class=p>(</span><span class=kt>int</span> <span class=nf>h</span><span class=p>,</span> <span class=n>Object</span> <span class=nf>k</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=p>((</span><span class=n>parent</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=o>?</span> <span class=n>root</span><span class=p>()</span> <span class=o>:</span> <span class=k>this</span><span class=p>).</span><span class=na>find</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span><span class=c1>//判断从当前节点还是root节点开始查找
</span><span class=c1></span>        <span class=p>}</span>


        <span class=cm>/**
</span><span class=cm>         * Finds the node starting at root p with the given hash and key.
</span><span class=cm>         * The kc argument caches comparableClassFor(key) upon first use
</span><span class=cm>         * comparing keys.
</span><span class=cm>         */</span>
        <span class=kd>final</span> <span class=nf>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span> <span class=nf>h</span><span class=p>,</span> <span class=n>Object</span> <span class=nf>k</span><span class=p>,</span> <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>kc</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>p</span> <span class=o>=</span> <span class=k>this</span><span class=p>;</span>
            <span class=k>do</span> <span class=p>{</span>
                <span class=kt>int</span> <span class=nf>ph</span><span class=p>,</span> <span class=n>dir</span><span class=p>;</span> <span class=n>K</span> <span class=nf>pk</span><span class=p>;</span>
                <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>pl</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>left</span><span class=p>,</span> <span class=n>pr</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>right</span><span class=p>,</span> <span class=n>q</span><span class=p>;</span>
                <span class=c1>//根据hash值查找 当前节点hash值大于h则 查左孩子 否则右孩子 当key相等或者equal时返回
</span><span class=c1></span>                <span class=k>if</span> <span class=p>((</span><span class=n>ph</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>hash</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>h</span><span class=p>)</span>
                    <span class=n>p</span> <span class=o>=</span> <span class=n>pl</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>ph</span> <span class=o>&lt;</span> <span class=n>h</span><span class=p>)</span>
                    <span class=n>p</span> <span class=o>=</span> <span class=n>pr</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>pk</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>key</span><span class=p>)</span> <span class=o>==</span> <span class=n>k</span> <span class=o>||</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>k</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>pk</span><span class=p>)))</span>
                    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pl</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span>
                    <span class=n>p</span> <span class=o>=</span> <span class=n>pr</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pr</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span>
                    <span class=n>p</span> <span class=o>=</span> <span class=n>pl</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>kc</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>||</span>
                          <span class=p>(</span><span class=n>kc</span> <span class=o>=</span> <span class=n>comparableClassFor</span><span class=p>(</span><span class=n>k</span><span class=p>))</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
                         <span class=p>(</span><span class=n>dir</span> <span class=o>=</span> <span class=n>compareComparables</span><span class=p>(</span><span class=n>kc</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>pk</span><span class=p>))</span> <span class=o>!=</span> <span class=n>0</span><span class=p>)</span>
                    <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=n>dir</span> <span class=o>&lt;</span> <span class=n>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>pl</span> <span class=o>:</span> <span class=n>pr</span><span class=p>;</span>
                <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>q</span> <span class=o>=</span> <span class=n>pr</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>kc</span><span class=p>))</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span><span class=c1>//不相等则从子树继续查找
</span><span class=c1></span>                    <span class=k>return</span> <span class=n>q</span><span class=p>;</span>
                <span class=k>else</span>
                    <span class=n>p</span> <span class=o>=</span> <span class=n>pl</span><span class=p>;</span>
            <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>);</span>
            <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
        <span class=p>}</span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 2019-08-15 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://xiaohei.im/2019/08/hashmap/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://xiaohei.im/tags/collections/><i class="fas fa-tag fa-fw"></i>collections</a></span></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://xiaohei.im/>主页</a></span></section></div><div class=post-nav><a href=https://xiaohei.im/2019/08/hashset/ class=prev rel=prev title=Collections-Hashset><i class="fas fa-angle-left fa-fw"></i>Collections-Hashset</a>
<a href=https://xiaohei.im/2019/08/arraylist/ class=next rel=next title=Collections-Arraylist>Collections-Arraylist<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"2019-08-15 13:19:18 \x2b0800 \x2b0800",title:"Collections-Hashmap",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xiaohei.im/>xiaoheiAh</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-98254666-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>