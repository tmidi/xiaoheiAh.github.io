<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on xiaohei&#39;s blog | Java Developer</title><link>https://xiaohei.im/posts/</link><description>Recent content in Posts on xiaohei&#39;s blog | Java Developer</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 29 Nov 2019 18:40:27 +0800</lastBuildDate><atom:link href="https://xiaohei.im/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>[学习笔记] Netty</title><link>https://xiaohei.im/2019/11/29/posts/netty/</link><pubDate>Fri, 29 Nov 2019 18:40:27 +0800</pubDate><guid>https://xiaohei.im/2019/11/29/posts/netty/</guid><description/></item><item><title>Redis HA - Cluster</title><link>https://xiaohei.im/2019/11/24/posts/cluster/</link><pubDate>Sun, 24 Nov 2019 11:48:17 +0800</pubDate><guid>https://xiaohei.im/2019/11/24/posts/cluster/</guid><description>&lt;p&gt;Redis 官方高可用(HA)方案之一: &lt;strong&gt;Cluster&lt;/strong&gt;.可以解决 &lt;code&gt;sentinel&lt;/code&gt; 模式单点写入的问题.&lt;/p&gt;</description></item><item><title>Redis HA - 哨兵模式</title><link>https://xiaohei.im/2019/11/23/posts/sentinel/</link><pubDate>Sat, 23 Nov 2019 17:56:15 +0800</pubDate><guid>https://xiaohei.im/2019/11/23/posts/sentinel/</guid><description>&lt;p&gt;Redis 官方高可用(HA)方案之一: &lt;strong&gt;哨兵模式&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Redis-复制功能探索</title><link>https://xiaohei.im/2019/11/16/posts/replication/</link><pubDate>Sat, 16 Nov 2019 14:24:40 +0800</pubDate><guid>https://xiaohei.im/2019/11/16/posts/replication/</guid><description>&lt;p&gt;之前对&lt;code&gt;redis&lt;/code&gt; 的复制只有一点点了解,这次想要搞明白的是:如何实现的复制? 复制会遇到哪些问题(时延/一致性保证/网络故障时的处理)? 如何解决?高可用实现方案?&lt;/p&gt;
&lt;p&gt;文章有部分是直接翻译的 &lt;a href=&#34;https://redis.io/topics/replication&#34;&gt;https://redis.io/topics/replication&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Redis-事件</title><link>https://xiaohei.im/2019/11/14/posts/event/</link><pubDate>Thu, 14 Nov 2019 15:01:45 +0800</pubDate><guid>https://xiaohei.im/2019/11/14/posts/event/</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事件驱动程序设计&lt;/strong&gt;（英语：&lt;strong&gt;Event-driven programming&lt;/strong&gt;）是一种电脑&lt;a href=&#34;https://zh.wikipedia.org/wiki/程式設計&#34;&gt;程序设计&lt;/a&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/模型&#34;&gt;模型&lt;/a&gt;。这种模型的程序运行流程是由用户的动作（如&lt;a href=&#34;https://zh.wikipedia.org/wiki/滑鼠&#34;&gt;鼠标&lt;/a&gt;的按键，键盘的按键动作）或者是由其他程序的&lt;a href=&#34;https://zh.wikipedia.org/wiki/訊息&#34;&gt;消息&lt;/a&gt;来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由&lt;a href=&#34;https://zh.wikipedia.org/wiki/程式設計師&#34;&gt;程序员&lt;/a&gt;来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=互動程序&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;交互程序&lt;/a&gt;（Interactive program）的情况下孕育而生的。 &lt;a href=&#34;https://zh.wikipedia.org/wiki/事件驅動程式設計&#34;&gt;&amp;ndash;wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>Redis-AOF持久化</title><link>https://xiaohei.im/2019/11/08/posts/aof/</link><pubDate>Fri, 08 Nov 2019 15:18:05 +0800</pubDate><guid>https://xiaohei.im/2019/11/08/posts/aof/</guid><description>&lt;p&gt;&lt;code&gt;RDB&lt;/code&gt; 和 &lt;code&gt;AOF&lt;/code&gt; 区别在于: 前者保存数据库快照,持久化所有键值对,后者通过保存 &lt;strong&gt;写命令&lt;/strong&gt; 保证数据库的状态.&lt;/p&gt;</description></item><item><title>Redis-RDB持久化</title><link>https://xiaohei.im/2019/11/06/posts/rdb/</link><pubDate>Wed, 06 Nov 2019 19:08:56 +0800</pubDate><guid>https://xiaohei.im/2019/11/06/posts/rdb/</guid><description>&lt;p&gt;&lt;code&gt;redis&lt;/code&gt; 为内存数据库,一旦服务器进程退出,服务器中的数据就不见了.所以内存中的数据需要持久化的硬盘中来保证可以在必要的时候进行故障恢复. &lt;code&gt;RDB&lt;/code&gt; 就是 &lt;code&gt;redis&lt;/code&gt; 提供的一种持久化方式.&lt;/p&gt;</description></item><item><title>Redis-数据库长什么样?</title><link>https://xiaohei.im/2019/11/06/posts/db/</link><pubDate>Wed, 06 Nov 2019 11:00:32 +0800</pubDate><guid>https://xiaohei.im/2019/11/06/posts/db/</guid><description/></item><item><title>Redis-万物皆「对象」</title><link>https://xiaohei.im/2019/11/04/posts/obj/</link><pubDate>Mon, 04 Nov 2019 18:56:15 +0800</pubDate><guid>https://xiaohei.im/2019/11/04/posts/obj/</guid><description>&lt;p&gt;Redis有很多种数据结构,但其并没有直接使用这些数据结构来构建这个 &lt;code&gt;NOSQL&lt;/code&gt;, 而是通过 &lt;code&gt;对象系统&lt;/code&gt; 完成了对所有数据结构的统一管理, 实现内存回收, 对象共享等特性~&lt;/p&gt;</description></item><item><title>Redis-分布式锁</title><link>https://xiaohei.im/2019/11/03/posts/distributed-lock/</link><pubDate>Sun, 03 Nov 2019 14:49:56 +0800</pubDate><guid>https://xiaohei.im/2019/11/03/posts/distributed-lock/</guid><description>&lt;p&gt;分布式锁有很多中实现(纯数据库,zookeeper,redis),纯数据库的受限于数据库性能,zk 可以保证加锁的顺序,是公平锁.Redis中的实现就是接下来要学习的.&lt;/p&gt;</description></item><item><title>Redis-数据结构</title><link>https://xiaohei.im/2019/10/24/posts/data-structure/</link><pubDate>Thu, 24 Oct 2019 09:59:11 +0800</pubDate><guid>https://xiaohei.im/2019/10/24/posts/data-structure/</guid><description>&lt;p&gt;系统学习 redis 相关的知识，从数据结构开始～&lt;/p&gt;</description></item><item><title>RabbitMQ-消息确认机制</title><link>https://xiaohei.im/2019/10/23/posts/rabbitmq-ack-confirm/</link><pubDate>Wed, 23 Oct 2019 11:22:13 +0800</pubDate><guid>https://xiaohei.im/2019/10/23/posts/rabbitmq-ack-confirm/</guid><description>&lt;p&gt;RabbitMQ在保证生产端与消费端的数据安全上,提供了消息确认的机制来保证. 消费端到 &lt;code&gt;broker&lt;/code&gt; 端的确认常叫做&lt;code&gt;ack机制&lt;/code&gt;, &lt;code&gt;broker&lt;/code&gt; 到生产端常叫做&lt;code&gt;confirm&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>Hexo =&gt; Hugo主题移植记录</title><link>https://xiaohei.im/2019/09/23/posts/hugo-theme-dev-note/</link><pubDate>Mon, 23 Sep 2019 19:08:35 +0800</pubDate><guid>https://xiaohei.im/2019/09/23/posts/hugo-theme-dev-note/</guid><description>&lt;blockquote&gt;
&lt;p&gt;最近使用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;作为博客引擎后,闲不下来总想去找一些简单好看的主题.在&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;官方的主题列表&lt;/a&gt;搜罗了一圈后,选择了&lt;a href=&#34;https://github.com/joway/hugo-theme-yinyang&#34;&gt;yinyang&lt;/a&gt;,非常简单,但是用了一段时间还是想找个功能全点的,无意中瞄到了一个博主的博客,主题特别吸引我,但是是 &lt;code&gt;hexo&lt;/code&gt; 平台的,搜了半天也没有人移植,就自己来吧~ 移植的过程中,遇到了挺多问题,也是这些问题慢慢的熟悉了hugo的模板结构.下面就来写一写自己遇到的问题~&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>RabbitMQ-消息分发机制</title><link>https://xiaohei.im/2019/09/21/posts/rabbitmq-msg-distribution/</link><pubDate>Sat, 21 Sep 2019 18:42:13 +0800</pubDate><guid>https://xiaohei.im/2019/09/21/posts/rabbitmq-msg-distribution/</guid><description>&lt;p&gt;rabbitmq有多种使用模式,在这里记录下不同模式的消息路由规则&lt;/p&gt;</description></item><item><title>RabbitMQ-入门及高可用集群部署</title><link>https://xiaohei.im/2019/09/04/posts/rabbitmq-guide-and-ha-cluster/</link><pubDate>Wed, 04 Sep 2019 14:42:13 +0800</pubDate><guid>https://xiaohei.im/2019/09/04/posts/rabbitmq-guide-and-ha-cluster/</guid><description/></item><item><title>AMQP消息模型</title><link>https://xiaohei.im/2019/09/03/posts/amqp-0-9-1-model-explained/</link><pubDate>Tue, 03 Sep 2019 10:04:49 +0800</pubDate><guid>https://xiaohei.im/2019/09/03/posts/amqp-0-9-1-model-explained/</guid><description/></item><item><title>Hystrix命令执行流程</title><link>https://xiaohei.im/2019/08/26/posts/rxjava-in-hystrix/</link><pubDate>Mon, 26 Aug 2019 15:25:08 +0800</pubDate><guid>https://xiaohei.im/2019/08/26/posts/rxjava-in-hystrix/</guid><description/></item><item><title>RxJava入门</title><link>https://xiaohei.im/2019/08/21/posts/rxjava-guide/</link><pubDate>Wed, 21 Aug 2019 16:09:48 +0800</pubDate><guid>https://xiaohei.im/2019/08/21/posts/rxjava-guide/</guid><description>&lt;blockquote&gt;
&lt;p&gt;本文基于 rxjava 1.x 版本&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>[LeetCode In Rust]189-Rotate Array</title><link>https://xiaohei.im/2019/08/21/posts/189-rotate-array/</link><pubDate>Wed, 21 Aug 2019 15:29:34 +0800</pubDate><guid>https://xiaohei.im/2019/08/21/posts/189-rotate-array/</guid><description/></item><item><title>[LeetCode In Rust]026-Remove Duplicates From Sorted Array</title><link>https://xiaohei.im/2019/08/20/posts/026-remove-duplicates-from-sorted-array/</link><pubDate>Tue, 20 Aug 2019 15:54:47 +0800</pubDate><guid>https://xiaohei.im/2019/08/20/posts/026-remove-duplicates-from-sorted-array/</guid><description/></item><item><title>[LeetCode In Rust]001-Two Sum</title><link>https://xiaohei.im/2019/08/16/posts/001-two-sum/</link><pubDate>Fri, 16 Aug 2019 18:22:05 +0800</pubDate><guid>https://xiaohei.im/2019/08/16/posts/001-two-sum/</guid><description/></item><item><title/><link>https://xiaohei.im/1/01/01/posts/array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaohei.im/1/01/01/posts/array/</guid><description>Easy =&amp;gt; 1252. Cells with Odd Values in a Matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public int oddCells(int n, int m, int[][] indices) { boolean[] oddRows = new boolean[n]; boolean[] oddCols = new boolean[m]; for(int[] item : indices) { // 遍历 indices 获取每一列每一行的出现次数是否为奇数 // 异或: 相同为0 不同为1 oddRows[item[0]] ^= true; oddCols[item[1]] ^= true; } int oddCnt = 0; for(int i = 0; i &amp;lt; n; i++) { for(int j = 0; j &amp;lt; m; j++) { // 行列出现 奇数次 + 偶数次 才能是产生奇数 oddCnt += oddRows[i] !</description></item><item><title/><link>https://xiaohei.im/1/01/01/posts/datastruturealgorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaohei.im/1/01/01/posts/datastruturealgorithm/</guid><description>复杂度分析 时间复杂度分析 只关注循环次数最多的一段代码 加法法则: 总复杂度等于量级最大的那段代码的复杂度 乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 常见时间复杂度 O(1) 常量阶 没有循环,顺序执行
O(n) 线性阶 循环 n 次
O(logn) 对数阶
1 2 3 4 5 i=1; while (i &amp;lt;= n) { i = i * 2; } 理解下来就是循环次数不是恒定的,就是 logn, 如果在上面代码中再套一层循环,就是 nlogn 了
O(nlogn) 线性对数阶
O(n^2^) 平方阶
双重 for 循环
O(m+n)/O(m*n) 代码中有两个数据规模
空间复杂度分析 空间复杂度自己的理解就是申请了多大的空间来使用.申请一个固定大小的数组,那其实就是个常量阶,申请一个 n 大小的数组,复杂度就是 O(n),然后复杂一点的就是 O(n^2^).</description></item><item><title/><link>https://xiaohei.im/1/01/01/posts/linkedlist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaohei.im/1/01/01/posts/linkedlist/</guid><description>链表需要注意的问题:
边界: 头结点尾结点的处理,链表长度为1时的处理 多画图,跟一次循环,边界情况也画图试试 思路大多都是 快慢指针 No.19 =&amp;gt; Remove Nth Node From End of List Medium
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public ListNode removeNthFromEnd(ListNode head, int n) { // 快慢指针 ListNode fast = head,slow = head,prev = null; while(fast.next != null) { if (--n &amp;lt;= 0) { // 先走 n 步后,slow 再走 prev = slow; slow = slow.</description></item></channel></rss>